Directory structure:
└── core/
    ├── README.md
    ├── CHANGELOG.md
    ├── index.html
    ├── package.json
    ├── rollup.config.js
    ├── tsconfig.json
    ├── .babelrc
    ├── .npmignore
    ├── script/
    │   └── fix-imports.js
    └── src/
        ├── PageBuilder.ts
        ├── css.d.ts
        ├── index.ts
        ├── canvas/
        │   ├── Canvas.ts
        │   ├── ComponentControls.ts
        │   ├── DeleteElement.ts
        │   ├── DragDropManager.ts
        │   ├── GridManager.ts
        │   └── PreviewPanel.ts
        ├── components/
        │   ├── ButtonComponent.ts
        │   ├── ContainerComponent.ts
        │   ├── HeaderComponent.ts
        │   ├── ImageComponent.ts
        │   ├── LinkComponent.ts
        │   ├── TableComponent.ts
        │   ├── TextComponent.ts
        │   ├── ThreeColumnContainer.ts
        │   ├── TwoColumnContainer.ts
        │   ├── VideoComponent.ts
        │   └── index.ts
        ├── icons/
        │   └── svgs.ts
        ├── navbar/
        │   └── CreateNavbar.ts
        ├── services/
        │   ├── HTMLGenerator.ts
        │   ├── HistoryManager.ts
        │   ├── JSONStorage.ts
        │   ├── MultiColumnContainer.ts
        │   └── ShortcutManager.ts
        ├── sidebar/
        │   ├── ConfigSidebar.ts
        │   ├── CreateSidebar.ts
        │   ├── CustomizationSidebar.ts
        │   └── LayerViewController.ts
        ├── styles/
        │   ├── linkComponent.css
        │   └── main.css
        ├── templates/
        │   ├── LandingPageTemplate.ts
        │   └── UserPortfolioTemplate.ts
        ├── types/
        │   ├── png.d.ts
        │   └── types.d.ts
        └── utils/
            ├── eventHelpers.ts
            ├── utilityFunctions.ts
            └── zipGenerator.ts

================================================
File: README.md
================================================
<h1 align="center">PageBuilder</h1><br><br>
<p align="center">
<a href="https://www.npmjs.com/package/@mindfiredigital/page-builder"><img src="https://img.shields.io/npm/v/@mindfiredigital/page-builder.svg?sanitize=true" alt="Version"></a>
<a href="https://www.npmjs.com/package/@mindfiredigital/page-builder"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg" alt="PRs"></a>
</p>

<br>

<p align="center"> A lightweight page builder library designed for creating static web pages with a drag-and-drop interface. This component library generates HTML output and supports customization options. Built with TypeScript and vanilla JavaScript for performance, it includes modular components, responsive previews, and data handling for layout storage and retrieval. </p>

<br>

## Live Demo

Click the button below to open the project on StackBlitz.

<a href="https://stackblitz.com/edit/stackblitz-starters-3d4yfpj4?file=index.html" target="_blank">
  <img src="https://developer.stackblitz.com/img/open_in_stackblitz.svg" alt="Open in StackBlitz">
</a>

## Screenshot

 <p align="center">
   <img alt="Screenshot of the Page builder" src="https://res.cloudinary.com/dodvwsaqj/image/upload/v1737367074/landing_sdtu4q.png"\>
</p>

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Getting Started with npm](#getting-started-with-npm)
- [Usage via CDN](#usage-via-cdn)
  - [CDN Usage Example](#cdn-usage-example)
- [Contributing](#contributing)
- [License](#license)

<br>

## Features

- **Component Structure**: Drag-and-drop components (text, images, buttons, headers, containers, etc.) to create a layout.
- **Responsive Preview**: Preview page layouts in different device modes (Desktop, Tablet, Mobile).
- **Configuration Sidebar**: Customize component properties like text, color, padding, and margin via a configuration sidebar.
- **Data Storage**: Save layout configurations in JSON format for easy retrieval and editing.
- **Layers**: Enabling users to manage component hierarchy visually.
- **Output HTML**: Export the final HTML layout for use in static web pages or other applications.

<br>

## Installation

To install the `@mindfiredigital/page-builder` npm package in your project, use the following command:

```bash
npm install @mindfiredigital/page-builder
```

<br>

## Getting Started with npm

- **Initialization**: Initialize the PageBuilder in your project.

```javascript
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Page Builder</title>
    <link rel="stylesheet" href="node_modules/@mindfiredigital/page-builder/dist/styles/main.css" />
  </head>
  <body>
    <header>
      <nav id="preview-navbar">
      </nav>
    </header>
    <div id="app">
        <div id="sidebar"></div>
      <div id="canvas" class="canvas"></div>
      <div id="customization">
        <h4 id="component-name">Component: None </h4>
        <div id="controls"></div>
        <div id="layers-view" class="hidden"></div>
      </div>
      <!-- Notification for saving -->
      <div id="notification" class="notification hidden"></div>
      <!-- Dialog for reset  -->
      <div id="dialog" class="dialog hidden">
        <div class="dialog-content">
          <p id="dialog-message"></p>
          <button id="dialog-yes" class="dialog-btn">Yes</button>
          <button id="dialog-no" class="dialog-btn">No</button>
        </div>
      </div>
    </div>

    <!-- Bundle JavaScript -->
    <script src="node_modules/@mindfiredigital/page-builder/dist/index.js"></script>
  </body>
</html>
```

<br>

## Usage via CDN

You can include @mindfiredigital/page-builder in your HTML file using the provided CDN link. This allows you to quickly test or use the library without installing it via npm.

```javascript

 <!-- CDN stylesheet -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mindfiredigital/page-builder/dist/styles/main.css" />

 <!--CDN Bundle JavaScript -->
<script src="https://cdn.jsdelivr.net/npm/@mindfiredigital/page-builder/dist/index.js"></script>
```

## CDN Usage Example

- **Initialization**: Initialize the PageBuilder in your project.

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Page Builder</title>
    <!-- CDN stylesheet -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@mindfiredigital/page-builder/dist/styles/main.css"
    />
  </head>
  <body>
    <header>
      <nav id="preview-navbar"></nav>
    </header>
    <div id="app">
      <div id="sidebar"></div>
      <div id="canvas" class="canvas"></div>
      <div id="customization">
        <h4 id="component-name">Component: None</h4>
        <div id="controls"></div>
        <div id="layers-view" class="hidden"></div>
      </div>
      <!-- Notification for saving -->
      <div id="notification" class="notification hidden"></div>
      <!-- Dialog for reset  -->
      <div id="dialog" class="dialog hidden">
        <div class="dialog-content">
          <p id="dialog-message"></p>
          <button id="dialog-yes" class="dialog-btn">Yes</button>
          <button id="dialog-no" class="dialog-btn">No</button>
        </div>
      </div>
    </div>

    <!--CDN Bundle JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/@mindfiredigital/page-builder/dist/index.js"></script>
  </body>
</html>
```

<br>

## Contributing

We welcome contributions from the community. If you'd like to contribute to the `Pagebuilder` npm package, please follow our [Contributing Guidelines](CONTRIBUTING.md).
<br>

## License

Copyright (c) Mindfire Digital llp. All rights reserved.

Licensed under the MIT license.



================================================
File: CHANGELOG.md
================================================
# @mindfiredigital/page-builder

## 1.6.0

### Minor Changes

- add keywords

## 1.5.0

### Minor Changes

- delete old chanset generated by githun actions



================================================
File: index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Page Builder</title>
    <link rel="stylesheet" href="dist/styles/main.css" />
  </head>
  <body>
    <header>
      <nav id="preview-navbar">
      </nav>
    </header>
    <div id="app">
        <div id="sidebar"></div>
      <div id="canvas" class="canvas"></div>
      <div id="customization">
        <h4 id="component-name">Component: None </h4>
        <div id="controls"></div>
        <div id="layers-view" class="hidden"></div>
      </div>
      <!-- Notification for saving -->
      <div id="notification" class="notification hidden"></div>
      <!-- Dialog for reset  -->
      <div id="dialog" class="dialog hidden">
        <div class="dialog-content">
          <p id="dialog-message"></p>
          <button id="dialog-yes" class="dialog-btn">Yes</button>
          <button id="dialog-no" class="dialog-btn">No</button>
        </div>
      </div>
    </div>

    <!-- Bundle JavaScript -->
    <script type="module" src="dist/index.js"></script>
  </body>
</html>



================================================
File: package.json
================================================
{
  "name": "@mindfiredigital/page-builder",
  "version": "1.6.0",
  "private": false,
  "description": "UI Page builder",
  "repository": {
    "type": "git",
    "url": "https://github.com/mindfiredigital/page-builder.git"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "files": [
    "dist"
  ],
  "types": "dist/index.d.ts",
  "main": "dist/index.js",
  "scripts": {
    "build:rollup": "rollup -c",
    "copy": "node script/fix-imports.js && npm run copy-assets",
    "build": "tsc && rollup -c && pnpm run copy",
    "start": "lite-server",
    "watch": "turbo run build --filter=. --watch",
    "test": "turbo run test",
    "lint": "turbo run lint",
    "copy-assets": "npm run copy-icons && npm run copy-styles",
    "copy-icons": "ncp ./src/icons ./dist/icons",
    "copy-styles": "ncp ./src/styles ./dist/styles",
    "release": "pnpm publish --access public"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "keywords": [
    "pagebuilder",
    "page-builder-react",
    "page-builder-web-component",
    "rich-page-builder",
    "html-editor",
    "typescript",
    "react",
    "framework",
    "cli",
    "javascript",
    "npm-package",
    "block-editor",
    "visual-editor",
    "no-code",
    "low-code",
    "component-based",
    "responsive-design",
    "components",
    "component",
    "react-component",
    "angular",
    "ui",
    "vue",
    "modern",
    "plugin",
    "eslint",
    "web",
    "webpack",
    "css"
  ],
  "author": "Mindfiredigital",
  "license": "MIT",
  "devDependencies": {
    "@babel/preset-env": "^7.26.0",
    "@rollup/plugin-babel": "^6.0.4",
    "@rollup/plugin-commonjs": "^28.0.2",
    "@rollup/plugin-node-resolve": "^16.0.0",
    "@rollup/plugin-terser": "^0.4.4",
    "@rollup/plugin-typescript": "^12.1.2",
    "babel": "^6.23.0",
    "lite-server": "^2.6.1",
    "ncp": "^2.0.0",
    "rollup": "^4.30.1",
    "rollup-plugin-dts": "^6.1.1",
    "rollup-plugin-postcss": "^4.0.2",
    "tsc-alias": "^1.8.10",
    "tslib": "^2.8.1",
    "turbo": "^1.10.0",
    "typescript": "^5.7.3"
  },
  "engines": {
    "node": ">=12.0.0"
  }
}



================================================
File: rollup.config.js
================================================
const typescript = require('@rollup/plugin-typescript');
const resolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const { babel } = require('@rollup/plugin-babel');
const terser = require('@rollup/plugin-terser');
const postcss = require('rollup-plugin-postcss');
const { dts } = require('rollup-plugin-dts');

module.exports = [
  {
    input: 'src/index.ts',
    output: {
      file: 'dist/index.js',
      format: 'cjs',
      exports: 'auto',
    },
    plugins: [
      resolve(),
      commonjs(),
      postcss({
        extensions: ['.css'],
        extract: true,
        minimize: true,
        inject: true,
      }),
      typescript({
        tsconfig: './tsconfig.json',
        declaration: true,
        declarationDir: './dist',
        compilerOptions: {
          outDir: './dist',
          declarationDir: './dist',
        },
      }),
      babel({
        babelHelpers: 'bundled',
        presets: ['@babel/preset-env'],
      }),
      terser(),
    ],
  },
  {
    input: 'src/index.ts',
    output: [{ file: 'dist/index.d.ts', format: 'es' }],
    plugins: [
      dts(),
      // Exclude CSS files from the declaration bundle
      {
        name: 'exclude-css',
        load(id) {
          if (id.endsWith('.css')) {
            return ''; // Ignore CSS files
          }
        },
      },
    ],
  },
];



================================================
File: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es6",
    "module": "esnext",
    "lib": ["dom", "es6", "es2015", "es2016", "es2017"],
    "declaration": true,
    "declarationDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true
  },
  "include": ["src/**/*", "src/PageBuilder.ts", "fix-imports.js"],
  "exclude": ["node_modules", "dist"]
}



================================================
File: .babelrc
================================================
{
  "presets": ["@babel/preset-env"]
}



================================================
File: .npmignore
================================================
/*
!dist/
!README.md


================================================
File: script/fix-imports.js
================================================
const fs = require('fs');
const path = require('path');

function addJsExtensions(dir) {
  const files = fs.readdirSync(dir);

  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      addJsExtensions(filePath);
    } else if (filePath.endsWith('.js')) {
      let content = fs.readFileSync(filePath, 'utf8');
      content = content.replace(/(from\s+["']\..+?)["']/g, "$1.js'");
      fs.writeFileSync(filePath, content, 'utf8');
    }
  });
}

addJsExtensions(path.join('dist'));



================================================
File: src/PageBuilder.ts
================================================
import { Canvas } from './canvas/Canvas';
import { Sidebar } from './sidebar/ConfigSidebar';
import { CustomizationSidebar } from './sidebar/CustomizationSidebar';
import { createSidebar } from './sidebar/CreateSidebar';
import { createNavbar } from './navbar/CreateNavbar';
import { HTMLGenerator } from './services/HTMLGenerator';
import { JSONStorage } from './services/JSONStorage';
import {
  showDialogBox,
  showNotification,
  syntaxHighlightCSS,
  syntaxHighlightHTML,
} from './utils/utilityFunctions';
import { createZipFile } from './utils/zipGenerator';
import { ShortcutManager } from './services/ShortcutManager';
import { PreviewPanel } from './canvas/PreviewPanel';
import './styles/main.css';
import { svgs } from './icons/svgs';

export class PageBuilder {
  private canvas: Canvas;
  private sidebar: Sidebar;
  private htmlGenerator: HTMLGenerator;
  private jsonStorage: JSONStorage;
  private previewPanel: PreviewPanel;
  private static headerInitialized = false;
  private dynamicComponents;
  private initialDesign: PageBuilderDesign | null;

  constructor(
    dynamicComponents: DynamicComponents = { Basic: [], Extra: [], Custom: {} },
    initialDesign: PageBuilderDesign | null = null
  ) {
    console.log(initialDesign, 'initial design of component');
    this.dynamicComponents = dynamicComponents;
    this.initialDesign = initialDesign;
    this.canvas = new Canvas();
    this.sidebar = new Sidebar(this.canvas);
    this.htmlGenerator = new HTMLGenerator(this.canvas);
    this.jsonStorage = new JSONStorage();
    this.previewPanel = new PreviewPanel();
    this.initializeEventListeners();
  }

  // Static method to reset header flag (called during cleanup)
  public static resetHeaderFlag() {
    PageBuilder.headerInitialized = false;
  }

  public initializeEventListeners() {
    // Re-initialize core components
    this.canvas = new Canvas();
    this.sidebar = new Sidebar(this.canvas);
    this.htmlGenerator = new HTMLGenerator(this.canvas);
    this.jsonStorage = new JSONStorage();
    this.previewPanel = new PreviewPanel();

    this.setupInitialComponents();
    this.setupSaveButton();
    this.setupResetButton();
    this.handleExport();
    this.setupExportHTMLButton();
    this.setupExportPDFButton();
    this.setupViewButton();
    this.setupPreviewModeButtons();
    this.setupUndoRedoButtons();
  }

  public setupInitialComponents() {
    createSidebar(this.dynamicComponents);

    // Pass initial design to Canvas.init
    Canvas.init(this.initialDesign);

    this.sidebar.init();
    ShortcutManager.init();
    CustomizationSidebar.init();

    // Create header logic - improved to handle re-initialization
    this.createHeaderIfNeeded();
  }

  private createHeaderIfNeeded() {
    const existingHeader = document.getElementById('page-builder-header');

    // Only create header if it doesn't exist
    if (!existingHeader) {
      const appElement = document.getElementById('app');
      if (appElement && appElement.parentNode) {
        const header = document.createElement('header');
        header.id = 'page-builder-header';
        header.appendChild(createNavbar());
        appElement.parentNode.insertBefore(header, appElement);
        PageBuilder.headerInitialized = true;
      } else {
        console.error('Error: #app not found in the DOM');
      }
    } else {
      // Header exists, mark as initialized
      PageBuilder.headerInitialized = true;
    }
  }

  // Rest of your methods remain the same...
  public setupSaveButton() {
    const saveButton = document.getElementById('save-btn');
    if (saveButton) {
      saveButton.addEventListener('click', () => {
        const layoutJSON = Canvas.getState();
        this.jsonStorage.save(layoutJSON);
        showNotification('Saving progress...');
      });
    }
  }

  public setupResetButton() {
    const resetButton = document.getElementById('reset-btn');
    if (resetButton) {
      resetButton.addEventListener('click', () => {
        showDialogBox(
          'Are you sure you want to reset the layout?',
          () => {
            this.jsonStorage.remove();
            Canvas.clearCanvas();
            showNotification('The saved layout has been successfully reset.');
          },
          () => {
            console.log('Layout reset canceled.');
          }
        );
      });
    }
  }

  /**
   * This function handles the event on clicking the export button
   * It opens up a drop down with 2 options for exporting
   * One is for html export and another is for json object export
   */
  public handleExport() {
    const exportBtn = document.getElementById('export-btn');

    if (exportBtn) {
      const dropdown = document.createElement('div');
      dropdown.classList.add('export-dropdown');

      // Create Option 1
      const option1 = document.createElement('div');
      option1.textContent = 'HTML';
      option1.classList.add('export-option');
      option1.id = 'export-html-btn';

      // Create Option 2
      const option2 = document.createElement('div');
      option2.textContent = 'PDF';
      option2.classList.add('export-option');
      option2.id = 'export-pdf-btn';

      dropdown.appendChild(option1);
      dropdown.appendChild(option2);

      exportBtn.appendChild(dropdown);

      exportBtn.addEventListener('click', event => {
        event.stopPropagation();
        dropdown.classList.toggle('visible');
      });

      // Hide dropdown when clicking outside
      document.addEventListener('click', event => {
        if (!exportBtn.contains(event.target as Node)) {
          dropdown.classList.remove('visible');
        }
      });
    }
  }

  /**
   * This function handles opening up the modal on clicking export to html option from drop down options
   * This generates expected html and css present on the canvas layout.
   */
  public setupExportHTMLButton() {
    const exportButton = document.getElementById('export-html-btn');
    if (exportButton) {
      exportButton.addEventListener('click', () => {
        const htmlGenerator = new HTMLGenerator(new Canvas());
        const html = htmlGenerator.generateHTML();
        const css = htmlGenerator.generateCSS();

        const highlightedHTML = syntaxHighlightHTML(html);
        const highlightedCSS = syntaxHighlightCSS(css);

        const modal = this.createExportModal(
          highlightedHTML,
          highlightedCSS,
          html,
          css
        );
        document.body.appendChild(modal);
        modal.classList.add('show');
      });
    }
  }

  /**
   * This function handles the exporting feature in PDF format
   */
  public setupExportPDFButton() {
    const exportButton = document.getElementById('export-pdf-btn');
    if (exportButton) {
      exportButton.addEventListener('click', () => {
        console.log('clicked on pdf');
        const htmlGenerator = new HTMLGenerator(new Canvas());
        const html = htmlGenerator.generateHTML();
        const css = htmlGenerator.generateCSS();

        // Create a new window
        const printWindow = window.open('', '_blank');

        if (printWindow) {
          const fullHTML = `
            <html>
              <head>
                <title>Export PDF</title>
                <style>
                  ${css} /* Generated CSS */
                  body {
                    margin: 0;
                    padding: 20px;
                    font-family: Arial, sans-serif;
                  }
                  @media print {
                    /* Ensure print styles are applied */
                    body { print-color-adjust: exact; -webkit-print-color-adjust: exact; }
                    
                    /* Remove browser headers and footers */
                    @page {
                      size: auto;
                      margin: 0mm;  /* Remove default margins */
                    }
                    
                    /* For Chrome/Safari */
                    @page { margin: 0; }
                    html { margin: 0; }
                  }
                </style>
              </head>
              <body>
                ${html} <!-- Generated HTML -->
              </body>
            </html>
          `;
          printWindow.document.write(fullHTML);
          printWindow.document.close();

          // Delay printing slightly to allow CSS processing
          setTimeout(() => {
            printWindow.print();
            printWindow.close();
          }, 500);
        }
      });
    }
  }

  public createExportModal(
    highlightedHTML: string,
    highlightedCSS: string,
    html: string,
    css: string
  ) {
    const modal = document.createElement('div');
    modal.id = 'export-dialog';
    modal.classList.add('modal');

    const modalContent = document.createElement('div');
    modalContent.classList.add('modal-content');

    const closeButton = this.createCloseButton(modal);
    modalContent.appendChild(closeButton);

    const htmlSection = this.createCodeSection('HTML', highlightedHTML);
    const cssSection = this.createCodeSection('CSS', highlightedCSS);

    const exportButton = this.createExportToZipButton(html, css);

    modalContent.appendChild(htmlSection);
    modalContent.appendChild(cssSection);
    modalContent.appendChild(exportButton);

    const exportButtonWrapper = document.createElement('div');
    exportButtonWrapper.classList.add('button-wrapper');
    exportButtonWrapper.appendChild(modalContent);

    modal.appendChild(exportButtonWrapper);

    this.setupModalEventListeners(modal);

    return modal;
  }

  public createCloseButton(modal: HTMLElement) {
    const closeButton = document.createElement('button');
    closeButton.textContent = '×';
    closeButton.classList.add('close-btn');
    closeButton.addEventListener('click', () => this.closeModal(modal));
    return closeButton;
  }

  public createCodeSection(title: string, highlightedContent: string) {
    const section = document.createElement('div');
    section.classList.add('modal-section');

    const titleElement = document.createElement('h2');
    titleElement.textContent = title;

    const codeBlock = document.createElement('div');
    codeBlock.classList.add('code-block');
    codeBlock.setAttribute('contenteditable', 'true');
    codeBlock.innerHTML = highlightedContent;

    section.appendChild(titleElement);
    section.appendChild(codeBlock);

    return section;
  }

  public createExportToZipButton(html: string, css: string) {
    const exportButton = document.createElement('button');
    exportButton.textContent = 'Export to ZIP';
    exportButton.classList.add('export-btn');
    exportButton.addEventListener('click', () => {
      const zipFile = createZipFile([
        { name: 'index.html', content: html },
        { name: 'styles.css', content: css },
      ]);

      const link = document.createElement('a');
      link.href = URL.createObjectURL(zipFile);
      link.download = 'exported-files.zip';
      link.click();
      URL.revokeObjectURL(link.href);
    });

    return exportButton;
  }

  public setupModalEventListeners(modal: HTMLElement) {
    modal.addEventListener('click', event => {
      if (event.target === modal) {
        this.closeModal(modal);
      }
    });

    document.addEventListener('keydown', event => {
      if (event.key === 'Escape') {
        this.closeModal(modal);
      }
    });
  }

  public closeModal(modal: HTMLElement) {
    modal.classList.remove('show');
    modal.classList.add('hide');
    setTimeout(() => modal.remove(), 300);
  }

  public setupViewButton() {
    const viewButton = document.getElementById('view-btn');
    if (viewButton) {
      viewButton.addEventListener('click', () => {
        const html = this.htmlGenerator.generateHTML();
        const fullScreenModal = this.createFullScreenPreviewModal(html);
        document.body.appendChild(fullScreenModal);
      });
    }
  }

  public createFullScreenPreviewModal(html: string) {
    const fullScreenModal = document.createElement('div');
    fullScreenModal.id = 'preview-modal';
    fullScreenModal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #f5f5f5;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 10px;
    `;

    const iframe = document.createElement('iframe');
    iframe.id = 'preview-iframe';
    iframe.style.cssText = `
      width: 97%;
      height: 90%;
      border: none;
      background: #fff;
      margin-right: 20px;
    `;
    iframe.srcdoc = html;
    fullScreenModal.appendChild(iframe);

    const closeButton = this.createPreviewCloseButton(fullScreenModal);
    fullScreenModal.appendChild(closeButton);

    const responsivenessContainer = this.createResponsivenessControls(iframe);
    fullScreenModal.insertBefore(responsivenessContainer, iframe);

    return fullScreenModal;
  }

  public createPreviewCloseButton(fullScreenModal: HTMLElement) {
    const closeButton = document.createElement('button');
    closeButton.id = 'close-modal-btn';
    closeButton.textContent = '✕';
    closeButton.style.cssText = `
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 20px;
      border: none;
      background: none;
      cursor: pointer;
    `;

    const closeModal = () => {
      setTimeout(() => fullScreenModal.remove(), 300);
      document.removeEventListener('keydown', escKeyListener);
    };

    closeButton.addEventListener('click', closeModal);

    const escKeyListener = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        closeModal();
      }
    };
    document.addEventListener('keydown', escKeyListener);

    return closeButton;
  }

  public createResponsivenessControls(iframe: HTMLIFrameElement) {
    const responsivenessContainer = document.createElement('div');
    responsivenessContainer.style.cssText = `
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    `;

    const sizes = [
      {
        icon: svgs.mobile,
        title: 'Desktop',
        width: '375px',
        height: '90%',
      },
      {
        icon: svgs.tablet,
        title: 'Tablet',
        width: '768px',
        height: '90%',
      },
      {
        icon: svgs.desktop,
        title: 'Mobile',
        width: '97%',
        height: '90%',
      },
    ];

    sizes.forEach(size => {
      const button = document.createElement('button');
      button.style.cssText = `
        padding: 5px;
        border: none;
        background: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      button.title = size.title;

      const iconContainer = document.createElement('div');
      iconContainer.innerHTML = size.icon;

      const svgElement = iconContainer.querySelector('svg');
      if (svgElement) {
        svgElement.style.width = '24px';
        svgElement.style.height = '24px';
        svgElement.classList.add('component-icon');
      }

      button.appendChild(iconContainer);

      button.addEventListener('click', () => {
        iframe.style.width = size.width;
        iframe.style.height = size.height;
      });

      responsivenessContainer.appendChild(button);
    });

    return responsivenessContainer;
  }

  public setupPreviewModeButtons() {
    const desktopButton = document.getElementById('preview-desktop');
    const tabletButton = document.getElementById('preview-tablet');
    const mobileButton = document.getElementById('preview-mobile');

    if (desktopButton) {
      desktopButton.addEventListener('click', () => {
        this.previewPanel.setPreviewMode('desktop');
      });
    }

    if (tabletButton) {
      tabletButton.addEventListener('click', () => {
        this.previewPanel.setPreviewMode('tablet');
      });
    }

    if (mobileButton) {
      mobileButton.addEventListener('click', () => {
        this.previewPanel.setPreviewMode('mobile');
      });
    }
  }

  public setupUndoRedoButtons() {
    const undoButton = document.getElementById('undo-btn');
    const redoButton = document.getElementById('redo-btn');

    if (undoButton) {
      undoButton.addEventListener('click', () => {
        Canvas.historyManager.undo();
      });
    }

    if (redoButton) {
      redoButton.addEventListener('click', () => {
        Canvas.historyManager.redo();
      });
    }
  }
}



================================================
File: src/css.d.ts
================================================
declare module '*.css' {
  const content: { [className: string]: string };
  export default content;
}



================================================
File: src/index.ts
================================================
import { PageBuilder } from './PageBuilder';

// Export the class
export { PageBuilder };

// Export the instance
export const PageBuilderCore = new PageBuilder();



================================================
File: src/canvas/Canvas.ts
================================================
import { DragDropManager } from './DragDropManager';
import { DeleteElementHandler } from './DeleteElement';
import { LandingPageTemplate } from './../templates/LandingPageTemplate';

import {
  ButtonComponent,
  HeaderComponent,
  ImageComponent,
  VideoComponent,
  TextComponent,
  ContainerComponent,
  TwoColumnContainer,
  ThreeColumnContainer,
  TableComponent,
  LinkComponent,
} from '../components/index';
import { HistoryManager } from '../services/HistoryManager';
import { JSONStorage } from '../services/JSONStorage';
import { ComponentControlsManager } from './ComponentControls';
import { CustomizationSidebar } from '../sidebar/CustomizationSidebar';
import { MultiColumnContainer } from '../services/MultiColumnContainer';
import { GridManager } from './GridManager';

export class Canvas {
  private static components: HTMLElement[] = [];
  private static canvasElement: HTMLElement;
  private static sidebarElement: HTMLElement;
  public static controlsManager: ComponentControlsManager;
  private static gridManager: GridManager;
  // Initialize CustomizationSidebar

  public static historyManager: HistoryManager; //accessible outside the Canvas class.
  public static jsonStorage: JSONStorage;

  // Add getters and setters for components to make it accessible outside the canvas class
  public static getComponents(): HTMLElement[] {
    return Canvas.components;
  }

  public static setComponents(components: HTMLElement[]): void {
    Canvas.components = components;
  }

  private static componentFactory: { [key: string]: () => HTMLElement | null } =
    {
      button: () => new ButtonComponent().create(),
      header: () => new HeaderComponent().create(),
      image: () => new ImageComponent().create(),
      video: () =>
        new VideoComponent(() => Canvas.historyManager.captureState()).create(),
      table: () => new TableComponent().create(2, 2),
      text: () => new TextComponent().create(),
      container: () => new ContainerComponent().create(),
      twoCol: () => new TwoColumnContainer().create(),
      threeCol: () => new ThreeColumnContainer().create(),
      // portfolio: () => new UserPortfolioTemplate().create(),
      landingpage: () => new LandingPageTemplate().create(),
      link: () => new LinkComponent().create(),
    };

  static init(initialData: PageBuilderDesign | null = null) {
    Canvas.canvasElement = document.getElementById('canvas')!;
    Canvas.sidebarElement = document.getElementById('sidebar')!;
    Canvas.canvasElement.addEventListener('drop', Canvas.onDrop.bind(Canvas));
    Canvas.canvasElement.addEventListener('dragover', event =>
      event.preventDefault()
    );
    Canvas.canvasElement.addEventListener('click', (event: MouseEvent) => {
      const component = event.target as HTMLElement;
      if (component) {
        CustomizationSidebar.showSidebar(component.id);
      }
    });
    // Set canvas to relative positioning
    Canvas.canvasElement.style.position = 'relative';

    Canvas.historyManager = new HistoryManager(Canvas.canvasElement);
    Canvas.jsonStorage = new JSONStorage();
    Canvas.controlsManager = new ComponentControlsManager(Canvas);

    //Initialize grid manager and initialize drop-view
    Canvas.gridManager = new GridManager();
    Canvas.gridManager.initializeDropPreview(Canvas.canvasElement);

    const dragDropManager = new DragDropManager(
      Canvas.canvasElement,
      Canvas.sidebarElement
    );
    dragDropManager.enable();
    console.log(initialData, 'initialData');
    // Load existing layout from local storage and render, if any
    if (initialData) {
      // Check for initialData presence and if it's not an empty array
      console.log('Canvas: Restoring state from initialData prop.');
      Canvas.restoreState(initialData);
    } else {
      const savedState = Canvas.jsonStorage.load();
      if (savedState) {
        // Check for savedState presence and if it's not empty
        console.log('Canvas: Restoring state from localStorage.');
        Canvas.restoreState(savedState); // savedState is already PageBuilderDesign
      } else {
        console.log(
          'Canvas: No initial design provided, starting with empty canvas.'
        );
        Canvas.clearCanvas(); // Ensure canvas is truly empty if nothing to load
      }
    }
  }

  /**
   * Dispatches a custom event indicating that the canvas design has changed.
   * The event detail contains the current design state.
   */
  static dispatchDesignChange() {
    console.log('event');
    if (Canvas.canvasElement) {
      const currentDesign = Canvas.getState();
      const event = new CustomEvent('design-change', {
        detail: currentDesign,
        bubbles: true,
        composed: true,
      });
      Canvas.canvasElement.dispatchEvent(event);
      console.log('Canvas: Dispatched design-change event', currentDesign);
    }
  }

  // Method to clear the canvas and remove all components
  static clearCanvas() {
    Canvas.canvasElement.innerHTML = '';
    Canvas.components = [];
    Canvas.historyManager.captureState(); // Capture cleared state for undo functionality if needed
    Canvas.gridManager.initializeDropPreview(Canvas.canvasElement);
    // Reinitialize the drop-preview after clearing the canvas
    Canvas.gridManager.initializeDropPreview(Canvas.canvasElement);

    Canvas.dispatchDesignChange();
  }

  static getState(): PageBuilderDesign {
    // Explicitly return PageBuilderDesign (PageComponent[])
    return Canvas.components.map((component: HTMLElement) => {
      const baseType = component.classList[0]
        .split(/\d/)[0]
        .replace('-component', '');

      const imageElement = component.querySelector('img') as HTMLImageElement;
      const imageSrc = imageElement ? imageElement.src : null;

      const videoElement = component.querySelector('video') as HTMLVideoElement;
      const videoSrc = videoElement ? videoElement.src : null;

      const computedStyles = window.getComputedStyle(component);
      const styles: { [key: string]: string } = {};

      const stylesToCapture = [
        'position',
        'top',
        'left',
        'right',
        'bottom',
        'width',
        'height',
        'min-width',
        'min-height',
        'max-width',
        'max-height',
        'margin',
        'padding',
        'background-color',
        'background-image',
        'border',
        'border-radius',
        'transform',
        'opacity',
        'z-index',
        'display',
        'flex-direction',
        'justify-content',
        'align-items',
        'flex-wrap',
        'font-size',
        'font-weight',
        'color',
        'text-align',
        'line-height',
      ];

      stylesToCapture.forEach(prop => {
        styles[prop] = computedStyles.getPropertyValue(prop);
      });

      const dataAttributes: { [key: string]: string } = {};
      Array.from(component.attributes)
        .filter(attr => attr.name.startsWith('data-'))
        .forEach(attr => {
          dataAttributes[attr.name] = attr.value;
        });

      // Capture props for custom components if they have any
      // This is a conceptual placeholder; you'd need a way to store/retrieve these.
      let componentProps: Record<string, any> = {};
      if (component.classList.contains('custom-component')) {
        // How your custom components store their data/props needs to be defined
        // Example: If props are stored in a data attribute
        const propsJson = component.getAttribute('data-component-props');
        if (propsJson) {
          try {
            componentProps = JSON.parse(propsJson);
          } catch (e) {
            console.error('Error parsing data-component-props:', e);
          }
        }
      }

      return {
        id: component.id,
        type: baseType,
        content: component.innerHTML, // Inner HTML includes component controls
        position: {
          x: component.offsetLeft,
          y: component.offsetTop,
        },
        dimensions: {
          width: component.offsetWidth,
          height: component.offsetHeight,
        },
        style: styles,
        inlineStyle: component.getAttribute('style') || '',
        classes: Array.from(component.classList),
        dataAttributes: dataAttributes,
        imageSrc: imageSrc,
        videoSrc: videoSrc,
        props: componentProps, // Include custom component props
      } as PageComponent; // Explicit cast for safety
    });
  }

  static restoreState(state: any) {
    Canvas.canvasElement.innerHTML = '';
    Canvas.components = [];

    state.forEach((componentData: any) => {
      const customSettings =
        componentData.dataAttributes['data-custom-settings'] || null;
      const component = Canvas.createComponent(
        componentData.type,
        customSettings
      );
      if (component) {
        if (!componentData.classes.includes('custom-component')) {
          component.innerHTML = componentData.content;
        }

        // Restore classes
        component.className = ''; // Clear existing classes
        componentData.classes.forEach((cls: string) => {
          component.classList.add(cls);
        });

        if (componentData.type === 'video' && componentData.videoSrc) {
          const videoElement = component.querySelector(
            'video'
          ) as HTMLVideoElement;
          const uploadText = component.querySelector(
            '.upload-text'
          ) as HTMLElement;

          videoElement.src = componentData.videoSrc;
          videoElement.style.display = 'block';
          uploadText.style.display = 'none';
        }

        // Restore inline styles
        if (componentData.inlineStyle) {
          component.setAttribute('style', componentData.inlineStyle);
        }

        // Restore computed styles
        if (componentData.computedStyle) {
          Object.keys(componentData.computedStyle).forEach(prop => {
            component.style.setProperty(
              prop,
              componentData.computedStyle[prop]
            );
          });
        }

        // Restore data attributes
        if (componentData.dataAttributes) {
          Object.entries(componentData.dataAttributes).forEach(
            ([key, value]) => {
              component.setAttribute(key, value as string);
            }
          );
        }

        // Add control buttons and listeners
        Canvas.controlsManager.addControlButtons(component);
        Canvas.addDraggableListeners(component);

        // Component-specific restoration
        if (component.classList.contains('container-component')) {
          ContainerComponent.restoreContainer(component);
        }

        // column-specific restoration
        if (
          component.classList.contains('twoCol-component') ||
          component.classList.contains('threeCol-component')
        ) {
          MultiColumnContainer.restoreColumn(component);
        }

        if (componentData.type === 'image') {
          ImageComponent.restoreImageUpload(component, componentData.imageSrc);
        }

        if (componentData.type === 'table') {
          TableComponent.restore(component);
        }

        if (componentData.type === 'link') {
          LinkComponent.restore(component);
        }

        // Append to the canvas and add to the components array
        Canvas.canvasElement.appendChild(component);
        Canvas.components.push(component);
      }
    });
    // Reinitialize the drop-preview after restoring the state
    Canvas.gridManager.initializeDropPreview(Canvas.canvasElement);
  }

  static onDrop(event: DragEvent) {
    event.preventDefault();
    if (
      (event.target as HTMLElement).classList.contains('container-component')
    ) {
      return;
    }

    const componentType = event.dataTransfer?.getData('component-type');
    let customSettings = event.dataTransfer?.getData('custom-settings');

    if (!componentType) {
      return;
    }

    // FIX 1: Handle empty string custom settings by getting them from the draggable element
    if (!customSettings || customSettings.trim() === '') {
      // Try to get settings from the draggable element in sidebar
      const draggableElement = document.querySelector(
        `[data-component="${componentType}"]`
      );
      if (draggableElement) {
        // Look for settings in the global customComponents registry
        if (
          (window as any).customComponents &&
          (window as any).customComponents[componentType]
        ) {
          const componentConfig = (window as any).customComponents[
            componentType
          ];
          if (componentConfig.settings) {
            customSettings = JSON.stringify(componentConfig.settings);
          }
        }
      }
    }

    const { gridX, gridY } = this.gridManager.mousePositionAtGridCorner(
      event,
      Canvas.canvasElement
    );

    const component = Canvas.createComponent(componentType, customSettings);

    if (component) {
      // Add unique class name
      const uniqueClass = Canvas.generateUniqueClass(componentType);
      component.id = uniqueClass;
      component.classList.add(uniqueClass);

      component.style.position = 'absolute';

      if (
        componentType === 'container' ||
        componentType === 'twoCol' ||
        componentType === 'threeCol'
      ) {
        // Specific logic for containers
        component.style.top = `${event.offsetY}px`;
      } else {
        // Position the component at the snapped grid corner
        component.style.position = 'absolute';
        component.style.left = `${gridX}px`;
        component.style.top = `${gridY}px`;
      }

      Canvas.components.push(component);
      Canvas.canvasElement.appendChild(component);
      Canvas.addDraggableListeners(component); // Add drag functionality
      //On adding new component to the canvas it captures the current state.
      Canvas.historyManager.captureState();
    }

    // Dispatch design change event
    Canvas.dispatchDesignChange();
  }

  // Reorder components in the Canvas model (in the components array)
  public static reorderComponent(fromIndex: number, toIndex: number): void {
    if (
      fromIndex < 0 ||
      toIndex < 0 ||
      fromIndex >= this.components.length ||
      toIndex >= this.components.length
    ) {
      console.error('Invalid indices for reordering');
      return;
    }

    const [movedComponent] = this.components.splice(fromIndex, 1);
    this.components.splice(toIndex, 0, movedComponent);

    const canvasContainer = document.getElementById('canvas-container');
    if (canvasContainer) {
      canvasContainer.innerHTML = '';
      this.components.forEach(component => {
        canvasContainer.appendChild(component);
      });
    }
    this.historyManager.captureState();
    Canvas.dispatchDesignChange();
  }

  // FIX 2: Enhanced createComponent method with better custom settings handling
  static createComponent(
    type: string,
    customSettings: string | null = null
  ): HTMLElement | null {
    let element: HTMLElement | null = null;

    // First try to create using component factory
    const componentFactoryFunction = Canvas.componentFactory[type];
    if (componentFactoryFunction) {
      element = componentFactoryFunction();
    }
    // If not in factory, check if it's a custom component with a tag name
    else {
      const tagNameElement = document.querySelector(
        `[data-component='${type}']`
      );

      const tagName = tagNameElement?.getAttribute('data-tag-name');

      if (tagName) {
        element = document.createElement(tagName);
        //Adding these classnames, since these will have prime role in history management.
        element.classList.add(`${type}-component`, 'custom-component');

        // FIX 3: Enhanced custom settings handling
        if (customSettings && customSettings.trim() !== '') {
          element.setAttribute('data-custom-settings', customSettings);

          // Also store in a way that's accessible to the CustomizationSidebar
          try {
            const parsedSettings = JSON.parse(customSettings);
            element.setAttribute(
              'data-component-settings',
              JSON.stringify(parsedSettings)
            );
          } catch (e) {
            console.warn('DEBUG - Could not parse custom settings:', e);
          }

          // Verify it was set:
        } else {
          // FIX 4: Fallback to global registry if no settings provided
          if (
            (window as any).customComponents &&
            (window as any).customComponents[type]
          ) {
            const componentConfig = (window as any).customComponents[type];
            if (componentConfig.settings) {
              const settingsJson = JSON.stringify(componentConfig.settings);
              element.setAttribute('data-custom-settings', settingsJson);
              element.setAttribute('data-component-settings', settingsJson);
            }
          }
        }
      } else {
        return null;
      }
    }

    if (element) {
      element.classList.add('editable-component');
      if (type != 'container') {
        element.classList.add('component-resizer');
      }
      const uniqueClass = Canvas.generateUniqueClass(type);
      element.setAttribute('id', uniqueClass);

      // Conditionally set contenteditable attribute
      if (type === 'image') {
        element.setAttribute('contenteditable', 'false');
      } else {
        element.setAttribute('contenteditable', 'true');
      }

      // Create label for showing class name on hover
      const label = document.createElement('span');
      label.className = 'component-label';
      label.textContent = uniqueClass;
      element.appendChild(label);

      //Add control for each component
      Canvas.controlsManager.addControlButtons(element);
    }

    return element;
  }

  static generateUniqueClass(
    type: string,
    isContainerComponent: boolean = false,
    containerClass: string | null = null
  ): string {
    if (isContainerComponent && containerClass) {
      // Handle container components
      let containerElement: any = Canvas.components.find(component =>
        component.classList.contains(containerClass)
      );

      if (!containerElement) {
        // If container is not found in Canvas.components, try searching in the whole document
        containerElement = document.querySelector(`.${containerClass}`);
        if (!containerElement) {
          return `${containerClass}-${type}1`; // Default fallback name if no container found
        }
      }

      const containerComponents = Array.from(
        containerElement.children
      ) as HTMLElement[];
      const typePattern = new RegExp(`${containerClass}-${type}(\\d+)`);

      // Find the highest existing number for this type in the container
      let maxNumber = 0;
      containerComponents.forEach(component => {
        component.classList.forEach(className => {
          const match = className.match(typePattern);
          if (match) {
            const number = parseInt(match[1]);
            maxNumber = Math.max(maxNumber, number);
          }
        });
      });

      return `${containerClass}-${type}${maxNumber + 1}`;
    } else {
      // Handle regular components
      const typePattern = new RegExp(`${type}(\\d+)`);
      let maxNumber = 0;

      // Find the highest existing number for this type across all components
      Canvas.components.forEach(component => {
        component.classList.forEach(className => {
          const match = className.match(typePattern);
          if (match) {
            const number = parseInt(match[1]);
            maxNumber = Math.max(maxNumber, number);
          }
        });
      });

      return `${type}${maxNumber + 1}`;
    }
  }

  static addDraggableListeners(element: HTMLElement) {
    element.setAttribute('draggable', 'true');
    element.style.cursor = 'grab';

    let dragStartX = 0;
    let dragStartY = 0;
    let elementStartX = 0;
    let elementStartY = 0;

    element.addEventListener('dragstart', (event: DragEvent) => {
      if (event.dataTransfer) {
        // Capture starting positions
        const canvasRect = Canvas.canvasElement.getBoundingClientRect();
        const rect = element.getBoundingClientRect();

        // Capture starting coordinates
        dragStartX = event.clientX;
        dragStartY = event.clientY;

        // Current element position relative to canvas
        elementStartX = rect.left - canvasRect.left;
        elementStartY = rect.top - canvasRect.top;

        event.dataTransfer.effectAllowed = 'move';
        element.style.cursor = 'grabbing';
      }
    });

    element.addEventListener('dragend', (event: DragEvent) => {
      event.preventDefault();
      // const canvasRect = Canvas.canvasElement.getBoundingClientRect();

      // Calculate movement delta
      const deltaX = event.clientX - dragStartX;
      const deltaY = event.clientY - dragStartY;

      // Calculate new position
      let newX = elementStartX + deltaX;
      let newY = elementStartY + deltaY;

      // Constrain within canvas boundaries
      const maxX = Canvas.canvasElement.offsetWidth - element.offsetWidth;
      const maxY = Canvas.canvasElement.offsetHeight - element.offsetHeight;

      newX = Math.max(0, Math.min(newX, maxX));
      newY = Math.max(0, Math.min(newY, maxY));

      // Set new position
      element.style.left = `${newX}px`;
      element.style.top = `${newY}px`;

      // Reset cursor
      element.style.cursor = 'grab';

      // Capture the state after dragging
      Canvas.historyManager.captureState();
      Canvas.dispatchDesignChange();
    });
  }

  // Unused for now, remove it later
  static exportLayout() {
    return Canvas.components.map(component => {
      return {
        type: component.className,
        content: component.innerHTML,
      };
    });
  }
}

const canvas = document.getElementById('canvas');

// Instantiate the DeleteElementHandler
const deleteElementHandler = new DeleteElementHandler();

if (canvas) {
  // Attach click event listener to canvas elements
  canvas.addEventListener('click', (event: MouseEvent) => {
    const target = event.target as HTMLElement;
    if (target !== canvas) {
      deleteElementHandler.selectElement(target);
    }
  });
}



================================================
File: src/canvas/ComponentControls.ts
================================================
import { Canvas } from './Canvas';

export class ComponentControlsManager {
  private canvas: typeof Canvas;
  //Image imports
  private icons = {
    delete:
      'https://res.cloudinary.com/dodvwsaqj/image/upload/v1737366522/delete-2-svgrepo-com_fwkzn7.svg',
  };

  constructor(canvas: typeof Canvas) {
    this.canvas = canvas;
  }

  /**
   * First check if there is already a div with class  as component-controls exists
   * Add a div for each components in which we can add control buttons
   * We have added delete button
   * NB: For image container we are using appendChild method instead of prepend since it is hampering the style.
   */
  public addControlButtons(element: HTMLElement): void {
    let ImageComponent = element.querySelector('img') as HTMLImageElement;
    let controlsDiv = element.querySelector(
      '.component-controls'
    ) as HTMLElement;
    if (!controlsDiv) {
      controlsDiv = document.createElement('div');
      controlsDiv.className = 'component-controls';
      if (ImageComponent) {
        element.appendChild(controlsDiv);
      } else {
        element.prepend(controlsDiv);
      }
    }
    const deleteIcon = this.createDeleteIcon(element);
    // Append the delete icon to controlsDiv, for future we can add other buttons to this controls div
    controlsDiv.appendChild(deleteIcon);
  }

  /**
   * First check if there is already deleteIcon within element
   * Creating delete icon
   * Adding click event for the  delete icon
   */
  private createDeleteIcon(element: HTMLElement): HTMLImageElement {
    let deleteIcon = element.querySelector('.delete-icon') as HTMLImageElement;
    if (!deleteIcon) {
      deleteIcon = document.createElement('img');
      deleteIcon.src = this.icons.delete;
      deleteIcon.alt = 'Delete';
      deleteIcon.classList.add('delete-icon');
      element.appendChild(deleteIcon);
    }
    // Attach the click event handler
    deleteIcon.onclick = e => {
      e.stopPropagation();
      console.log('clciked');
      this.handleDelete(element);
    };
    return deleteIcon;
  }

  /**
   * This function handle deletion of component
   * It captures the current state and state after deletion for undo redo functionality
   * Then removes the component from canvas
   * And updates the component list with the help of getters and setters
   */
  private handleDelete(element: HTMLElement): void {
    this.canvas.historyManager.captureState();
    element.remove();
    const updatedComponents = this.canvas
      .getComponents()
      .filter(comp => comp !== element);
    this.canvas.setComponents(updatedComponents);
    this.canvas.historyManager.captureState();
    console.log('event');
    this.canvas.dispatchDesignChange();
  }
}



================================================
File: src/canvas/DeleteElement.ts
================================================
export class DeleteElementHandler {
  private selectedElement: HTMLElement | null = null;

  constructor() {
    // Listen for keydown events
    document.addEventListener('keydown', this.handleKeydown.bind(this));
  }

  // Method to delete the selected element
  private deleteSelectedElement(): void {
    if (this.selectedElement) {
      this.selectedElement.remove();
      this.selectedElement = null; // Clear selection
    }
  }

  // Handle keydown events
  private handleKeydown(event: KeyboardEvent): void {
    if (event.key === 'Delete') {
      this.deleteSelectedElement();
    }
  }

  // Method to set the selected element
  public selectElement(element: HTMLElement): void {
    if (this.selectedElement) {
      this.selectedElement.classList.remove('selected');
    }

    this.selectedElement = element;
    this.selectedElement.classList.add('selected');
  }
}



================================================
File: src/canvas/DragDropManager.ts
================================================
export class DragDropManager {
  private canvas: HTMLElement;
  private sidebar: HTMLElement;

  constructor(canvas: HTMLElement, sidebar: HTMLElement) {
    this.canvas = canvas;
    this.sidebar = sidebar;
  }

  enable() {
    // Select all `.draggable` items in the sidebar
    const draggableItems = this.sidebar.querySelectorAll('.draggable');
    draggableItems.forEach(item => {
      item.addEventListener('dragstart', event => {
        const dragEvent = event as DragEvent;
        console.log(`Dragging component: ${item.id}`); // Debug log
        dragEvent.dataTransfer?.setData('component-type', item.id);
        const settingsData = item.getAttribute('data-component-settings');
        if (settingsData) {
          dragEvent.dataTransfer?.setData('custom-settings', settingsData);
          console.log(
            `Setting custom settings from DOM:`,
            JSON.parse(settingsData)
          );
        }
      });
    });
  }
}



================================================
File: src/canvas/GridManager.ts
================================================
export class GridManager {
  private cellSize: number;

  /**
   * Constructor for GridManager.
   * @param cellSize - The size of each grid cell, default is 20px.
   * Used to define the snapping behavior for grid-based alignment.
   */
  constructor(cellSize: number = 20) {
    this.cellSize = cellSize;
  }

  /**
   * Initializes the drop-preview element for the canvas.
   * Ensures there is only one drop-preview element at a time.
   * Sets up drag-and-drop event listeners for positioning previews.
   * Updates the visual grid alignment for drag-over operations.
   * Called during initialization or restoration of the canvas.
   */
  initializeDropPreview(canvasElement: HTMLElement) {
    const existingDropPreview = canvasElement.querySelector('.drop-preview');
    if (existingDropPreview) {
      existingDropPreview.remove();
    }

    const dropPreview = document.createElement('div');
    dropPreview.className = 'drop-preview';
    canvasElement.appendChild(dropPreview);

    canvasElement.addEventListener('dragover', event => {
      event.preventDefault();
      this.showGridCornerHighlight(event, dropPreview, canvasElement);
    });

    canvasElement.addEventListener('dragleave', () => {
      dropPreview.classList.remove('visible');
    });
  }

  /**
   * Updates the position of the drop-preview to align with the grid.
   * Calculates the nearest grid corner based on mouse position.
   * Ensures the drop-preview element reflects the correct alignment.
   * Enhances drag-and-drop UX by snapping the preview to the grid.
   * Called on every drag-over event over the canvas element.
   */
  showGridCornerHighlight(
    event: DragEvent,
    dropPreview: HTMLElement,
    canvasElement: HTMLElement
  ) {
    const gridCellSize = 20;
    const { gridX, gridY } = this.mousePositionAtGridCorner(
      event,
      canvasElement
    );

    dropPreview.style.left = `${gridX}px`;
    dropPreview.style.top = `${gridY}px`;
    dropPreview.style.width = `${gridCellSize}px`;
    dropPreview.style.height = `${gridCellSize}px`;
    dropPreview.classList.add('visible');
  }

  /**
   * Calculates the nearest grid corner position based on mouse coordinates.
   * Determines the mouse position relative to the canvas element.
   * Snaps the mouse position to the closest grid corner for alignment.
   * Supports grid-based snapping behavior during drag-and-drop.
   * Returns an object containing the grid-aligned X and Y coordinates.
   */
  mousePositionAtGridCorner(event: DragEvent, canvasElement: HTMLElement): any {
    const gridCellSize = 20;
    const canvasRect = canvasElement.getBoundingClientRect();

    const mouseX = event.clientX - canvasRect.left;
    const mouseY = event.clientY - canvasRect.top;

    const gridX = Math.floor(mouseX / gridCellSize) * gridCellSize;
    const gridY = Math.floor(mouseY / gridCellSize) * gridCellSize;

    return { gridX, gridY };
  }

  /**
   * Retrieves the size of each grid cell.
   * Provides a way to access the configured grid size for alignment.
   * Useful for other components needing grid cell dimensions.
   * Returns the current cell size set during initialization.
   * The default value is 20px unless overridden in the constructor.
   */
  getCellSize(): number {
    return this.cellSize;
  }
}



================================================
File: src/canvas/PreviewPanel.ts
================================================
export class PreviewPanel {
  setPreviewMode(size: 'desktop' | 'tablet' | 'mobile') {
    const canvas = document.getElementById('canvas')!;

    // First Remove all classes that start with 'preview-'
    canvas.classList.forEach(className => {
      if (className.startsWith('preview-')) {
        canvas.classList.remove(className);
      }
    });

    // Add the new preview class
    canvas.classList.add(`preview-${size}`);
  }
}



================================================
File: src/components/ButtonComponent.ts
================================================
export class ButtonComponent {
  create(label: string = 'Click Me'): HTMLElement {
    const element = document.createElement('button');
    element.innerText = label; // Default button text
    element.classList.add('button-component');

    // Optional styling
    element.style.padding = '10px 20px';
    element.style.fontSize = '14px';
    element.style.borderRadius = '4px';
    element.style.cursor = 'pointer';

    return element;
  }
}



================================================
File: src/components/ContainerComponent.ts
================================================
import { Canvas } from '../canvas/Canvas';
import { ImageComponent } from './ImageComponent';

export class ContainerComponent {
  private element: HTMLElement;
  private resizers: HTMLElement;
  private readonly MINIMUM_SIZE = 20;
  private originalWidth: number = 0;
  private originalHeight: number = 0;
  private originalX: number = 0;
  private originalY: number = 0;
  private originalMouseX: number = 0;
  private originalMouseY: number = 0;
  private currentResizer: HTMLElement | null = null;

  constructor() {
    this.element = document.createElement('div');
    this.element.classList.add('container-component');
    this.element.setAttribute('draggable', 'true');

    // Initialize resizers container
    this.resizers = document.createElement('div');
    this.resizers.classList.add('resizers');
    this.element.appendChild(this.resizers);

    // Add resizer handles
    this.addResizeHandles();

    // Add styles
    this.addStyles();

    // Add event listeners
    this.initializeEventListeners();
  }

  private addResizeHandles(): void {
    const positions = [
      { class: 'top-left', cursor: 'nwse-resize' },
      { class: 'top-right', cursor: 'nesw-resize' },
      { class: 'bottom-left', cursor: 'nesw-resize' },
      { class: 'bottom-right', cursor: 'nwse-resize' },
    ];

    positions.forEach(position => {
      const resizer = document.createElement('div');
      resizer.classList.add('resizer', position.class);
      resizer.addEventListener('mousedown', e => this.initResize(e, resizer));
      this.resizers.appendChild(resizer);
    });
  }

  private initResize(e: MouseEvent, resizer: HTMLElement): void {
    e.preventDefault();
    this.currentResizer = resizer;

    // Store original dimensions and positions
    this.originalWidth = parseFloat(
      getComputedStyle(this.element).getPropertyValue('width')
    );
    this.originalHeight = parseFloat(
      getComputedStyle(this.element).getPropertyValue('height')
    );
    this.originalX = this.element.getBoundingClientRect().left;
    this.originalY = this.element.getBoundingClientRect().top;
    this.originalMouseX = e.pageX;
    this.originalMouseY = e.pageY;

    // Add resize events
    window.addEventListener('mousemove', this.resize);
    window.addEventListener('mouseup', this.stopResize);
  }

  private resize = (e: MouseEvent): void => {
    if (!this.currentResizer) return;

    const deltaX = e.pageX - this.originalMouseX;
    const deltaY = e.pageY - this.originalMouseY;

    if (this.currentResizer.classList.contains('bottom-right')) {
      const width = this.originalWidth + deltaX;
      const height = this.originalHeight + deltaY;

      if (width > this.MINIMUM_SIZE) {
        this.element.style.width = `${width}px`;
      }
      if (height > this.MINIMUM_SIZE) {
        this.element.style.height = `${height}px`;
      }
    } else if (this.currentResizer.classList.contains('bottom-left')) {
      const height = this.originalHeight + deltaY;
      const width = this.originalWidth - deltaX;

      if (height > this.MINIMUM_SIZE) {
        this.element.style.height = `${height}px`;
      }
      if (width > this.MINIMUM_SIZE) {
        this.element.style.width = `${width}px`;
        this.element.style.left = `${this.originalX + deltaX}px`;
      }
    } else if (this.currentResizer.classList.contains('top-right')) {
      const width = this.originalWidth + deltaX;
      const height = this.originalHeight - deltaY;

      if (width > this.MINIMUM_SIZE) {
        this.element.style.width = `${width}px`;
      }
      if (height > this.MINIMUM_SIZE) {
        this.element.style.height = `${height}px`;
        this.element.style.top = `${this.originalY + deltaY}px`;
      }
    } else if (this.currentResizer.classList.contains('top-left')) {
      const width = this.originalWidth - deltaX;
      const height = this.originalHeight - deltaY;

      if (width > this.MINIMUM_SIZE) {
        this.element.style.width = `${width}px`;
        this.element.style.left = `${this.originalX + deltaX}px`;
      }
      if (height > this.MINIMUM_SIZE) {
        this.element.style.height = `${height}px`;
        this.element.style.top = `${this.originalY + deltaY}px`;
      }
    }
  };

  /**
   * On mouse up event the resizing stops and captures the state
   * Which will help keep tracking of state for undo/redo purpose
   */
  private stopResize = (): void => {
    window.removeEventListener('mousemove', this.resize);
    window.removeEventListener('mouseup', this.stopResize);
    this.currentResizer = null;

    //capture each resized state
    Canvas.historyManager.captureState();
  };

  private initializeEventListeners(): void {
    this.element.addEventListener('dragstart', this.onDragStart.bind(this));
    this.element.addEventListener('drop', this.onDrop.bind(this));
    this.element.addEventListener('dragover', event => event.preventDefault());
    this.element.addEventListener('mouseover', this.onMouseOver.bind(this));
    this.element.addEventListener('mouseleave', this.onMouseLeave.bind(this));
  }

  private onDragStart(event: DragEvent): void {
    event.stopPropagation();
  }

  private makeDraggable(element: HTMLElement): void {
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let offsetX = 0;
    let offsetY = 0;

    const onMouseDown = (event: MouseEvent) => {
      event.preventDefault();
      event.stopPropagation();
      isDragging = true;

      // Calculate initial positions
      startX = event.clientX;
      startY = event.clientY;
      const rect = element.getBoundingClientRect();
      offsetX = rect.left;
      offsetY = rect.top;

      // Add event listeners for dragging
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
    };

    const onMouseMove = (event: MouseEvent) => {
      if (!isDragging) return;

      // Calculate the new position
      const deltaX = event.clientX - startX;
      const deltaY = event.clientY - startY;

      // Update the element's position using CSS transform
      element.style.transform = `translate(${offsetX + deltaX}px, ${offsetY + deltaY}px)`;
    };

    const onMouseUp = () => {
      isDragging = false;

      // Remove event listeners to stop dragging
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };

    // Attach the mousedown event to the element
    element.addEventListener('mousedown', onMouseDown);
  }

  private onDrop(event: DragEvent): void {
    event.preventDefault();
    event.stopPropagation();

    const componentType = event.dataTransfer?.getData('component-type');
    if (!componentType) return;

    const component = Canvas.createComponent(componentType);
    if (!component) return;

    const containerClass = this.element.classList[2];
    const uniqueClass = Canvas.generateUniqueClass(
      componentType,
      true,
      containerClass
    );
    component.classList.add(uniqueClass);

    const label = document.createElement('span');
    label.className = 'component-label';
    label.textContent = uniqueClass;
    component.id = uniqueClass;
    label.style.display = 'none';
    component.appendChild(label);

    component.addEventListener('mouseenter', e => this.showLabel(e, component));
    component.addEventListener('mouseleave', e => this.hideLabel(e, component));

    this.element.appendChild(component);

    // Apply draggable functionality to the new component
    this.makeDraggable(component);

    // Capture state for undo/redo
    Canvas.historyManager.captureState();
  }

  private showLabel(event: MouseEvent, component: HTMLElement): void {
    event.stopPropagation();
    const label = component.querySelector('.component-label') as HTMLElement;
    if (label) {
      label.style.display = 'block';
    }
  }

  private hideLabel(event: MouseEvent, component: HTMLElement): void {
    event.stopPropagation();
    const label = component.querySelector('.component-label') as HTMLElement;
    if (label) {
      label.style.display = 'none';
    }
  }

  private onMouseOver(event: MouseEvent) {
    event.stopPropagation();
    const elements = document.querySelectorAll('.container-highlight');

    // Loop through each element and remove the class
    elements.forEach(element => {
      element.classList.remove('container-highlight');
    });
    if (event.target === this.element) {
      this.element.classList.add('container-highlight');
    }
  }

  private onMouseLeave(event: MouseEvent): void {
    if (event.target === this.element) {
      this.element.classList.remove('container-highlight');
    }
  }

  private addStyles(): void {
    const style = document.createElement('style');
    style.textContent = `
      .container-component {
        position: relative !important;
        display: flex;
        min-width: 100px;
        min-height: 100px;
        cursor: grab;
        border: 1px solid #ddd;
      }

      .resizer {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: white;
        border: 2px solid #4286f4;
        position: absolute;
      }

      .resizer.top-left {
        left: -5px;
        top: -5px;
        cursor: nwse-resize;
      }

      .resizer.top-right {
        right: -5px;
        top: -5px;
        cursor: nesw-resize;
      }

      .resizer.bottom-left {
        left: -5px;
        bottom: -5px;
        cursor: nesw-resize;
      }

      .resizer.bottom-right {
        right: -5px;
        bottom: -5px;
        cursor: nwse-resize;
      }
    `;
    document.head.appendChild(style);
  }

  public create(): HTMLElement {
    return this.element;
  }

  private static restoreResizer(element: HTMLElement): void {
    // Remove any existing resizers
    const oldResizers = element.querySelector('.resizers');
    if (oldResizers) {
      oldResizers.remove();
    }

    // Create new resizers container
    const resizersDiv = document.createElement('div');
    resizersDiv.classList.add('resizers');

    // Create temporary container instance to bind event listeners
    const container = new ContainerComponent();
    container.element = element;
    container.resizers = resizersDiv;

    // Add resize handles
    container.addResizeHandles();

    // Add new resizers to the element
    element.appendChild(resizersDiv);
  }

  public static restoreContainer(container: HTMLElement): void {
    // Restore resizer functionality
    ContainerComponent.restoreResizer(container);

    // Create a temporary instance of ContainerComponent to reuse its methods
    const containerInstance = new ContainerComponent();
    containerInstance.element = container;

    // Reapply controls to child components inside the container
    const containerChildren = container.querySelectorAll('.editable-component');
    containerChildren.forEach((child: any) => {
      // Add control buttons and draggable listeners
      Canvas.controlsManager.addControlButtons(child);
      Canvas.addDraggableListeners(child);

      // Bind the showLabel and hideLabel methods
      child.addEventListener('mouseenter', (event: MouseEvent) =>
        containerInstance.showLabel(event, child)
      );
      child.addEventListener('mouseleave', (event: MouseEvent) =>
        containerInstance.hideLabel(event, child)
      );

      // If the child is an image component, restore the image upload feature
      if (child.classList.contains('image-component')) {
        const imageSrc = child.querySelector('img')?.getAttribute('src') || ''; // Get the saved image source
        ImageComponent.restoreImageUpload(child, imageSrc);
      }

      // If the child is itself a container, restore it recursively
      if (child.classList.contains('container-component')) {
        this.restoreContainer(child);
      }
    });
  }
}



================================================
File: src/components/HeaderComponent.ts
================================================
export class HeaderComponent {
  create(level: number = 1, text: string = 'Header'): HTMLElement {
    const element = document.createElement(`h${level}`); // Allows setting the header level (h1, h2, etc.)
    element.innerText = text;
    element.classList.add('header-component');

    return element;
  }
}



================================================
File: src/components/ImageComponent.ts
================================================
export class ImageComponent {
  create(src: string | null = null): HTMLElement {
    // Create a container for the image and label
    const container = document.createElement('div');
    container.classList.add('image-component');
    const uniqueContainerId = `image-container-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
    container.id = uniqueContainerId;

    // Set container styles
    container.style.width = '300px';
    container.style.height = '300px';
    container.style.position = 'relative';
    container.style.backgroundColor = src ? 'transparent' : '#f0f0f0';
    container.style.display = 'flex';
    container.style.border = 'none';
    container.style.alignItems = 'center';
    container.style.justifyContent = 'center';

    // Create upload text
    const uploadText = document.createElement('div');
    uploadText.style.color = '#666666';
    uploadText.style.border = 'none';
    uploadText.style.display = src ? 'none' : 'block';

    // Create the file input for uploading an image (hidden by default)
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'none';
    fileInput.addEventListener('change', event =>
      ImageComponent.handleFileChange(event, container, uploadText)
    );

    // Create the pencil icon button
    const pencilButton = document.createElement('button');
    pencilButton.classList.add('upload-btn');
    pencilButton.innerHTML = '🖊️';
    pencilButton.style.position = 'absolute';
    pencilButton.style.padding = '8px';
    pencilButton.style.background = 'transparent';
    pencilButton.style.border = 'none';
    pencilButton.style.cursor = 'pointer';
    pencilButton.style.opacity = '0';
    pencilButton.style.transition = 'opacity 0.2s';
    pencilButton.style.left = '50%';
    pencilButton.style.top = '50%';
    pencilButton.style.transform = 'translate(-50%, -50%)';
    pencilButton.style.fontSize = '24px';
    pencilButton.addEventListener('click', () => fileInput.click());

    // Create the image element
    const element = document.createElement('img');
    const uniqueImageId = `${uniqueContainerId}-img`;
    element.id = uniqueImageId;
    element.style.width = '100%';
    element.style.height = '100%';
    element.style.objectFit = 'contain';
    element.style.border = 'none';
    element.style.display = 'none';

    // Set image source if provided
    if (src) {
      element.src = src;
      element.style.display = 'block';
    }

    // Add hover effect to show pencil button
    container.addEventListener('mouseenter', () => {
      pencilButton.style.opacity = '1';
    });
    container.addEventListener('mouseleave', () => {
      pencilButton.style.opacity = '0';
    });

    // Append elements to container
    container.appendChild(uploadText);
    container.appendChild(fileInput);
    container.appendChild(pencilButton);
    container.appendChild(element);

    return container;
  }

  static handleFileChange(
    event: Event,
    container: HTMLElement,
    uploadText: HTMLElement
  ): void {
    const fileInput = event.target as HTMLInputElement;
    const file = fileInput.files ? fileInput.files[0] : null;

    if (file) {
      const reader = new FileReader();

      reader.onload = function () {
        const base64String = reader.result as string;
        const imageElement = container.querySelector('img');

        if (imageElement) {
          imageElement.src = base64String;
          imageElement.style.display = 'block';
          uploadText.style.display = 'none';
          // Make background transparent after image is loaded
          container.style.backgroundColor = 'transparent';
        }
      };

      reader.readAsDataURL(file);
    }
  }

  static restoreImageUpload(component: HTMLElement, src: string): void {
    const uploadText = component.querySelector(
      'div:not(.upload-btn)'
    ) as HTMLElement;
    const fileInput = component.querySelector(
      'input[type="file"]'
    ) as HTMLInputElement;
    const pencilButton = component.querySelector('.upload-btn') as HTMLElement;
    const imageElement = component.querySelector('img') as HTMLImageElement;

    // Restore event listeners
    fileInput.addEventListener('change', event =>
      this.handleFileChange(event, component, uploadText)
    );
    pencilButton.addEventListener('click', () => fileInput.click());

    // Restore image and text visibility
    if (src) {
      imageElement.src = src;
      imageElement.style.display = 'block';
      uploadText.style.display = 'none';
      component.style.backgroundColor = 'transparent';
    } else {
      imageElement.style.display = 'none';
      uploadText.style.display = 'block';
      component.style.backgroundColor = '#f0f0f0';
    }

    // Restore hover functionality
    component.addEventListener('mouseenter', () => {
      pencilButton.style.opacity = '1';
    });
    component.addEventListener('mouseleave', () => {
      pencilButton.style.opacity = '0';
    });
  }
}



================================================
File: src/components/LinkComponent.ts
================================================
export class LinkComponent {
  private link: HTMLAnchorElement | null = null;
  private isEditing: boolean = false;

  /**
   * Creates a link component with editing functionality.
   * Users can edit the link's URL and choose whether it opens in the same tab or a new tab.
   * @param href - The initial URL for the link (default: '#').
   * @param label - The text displayed for the link (default: 'Click Here').
   * @returns A div element containing the link, edit button, and edit form.
   */
  create(href: string = '#', label: string = 'Click Here'): HTMLDivElement {
    const container = document.createElement('div');
    container.classList.add('link-component');

    // Create the link element
    this.link = document.createElement('a');
    this.link.href = href;
    this.link.innerText = label;
    this.link.classList.add('link-component-label');

    const editButton = document.createElement('button');
    editButton.innerHTML = '🖊️';
    editButton.classList.add('edit-link');

    const editForm = document.createElement('div');
    editForm.classList.add('edit-link-form');

    const urlInput = document.createElement('input');
    urlInput.type = 'url';
    urlInput.value = href;
    urlInput.placeholder = 'Enter URL';

    // New checkbox for toggle
    const targetCheckbox = document.createElement('input');
    targetCheckbox.type = 'checkbox';
    const checkboxLabel = document.createElement('label');
    checkboxLabel.innerHTML = 'Open in new tab';
    checkboxLabel.appendChild(targetCheckbox);

    const saveButton = document.createElement('button');
    saveButton.innerHTML = 'Save';

    editForm.appendChild(urlInput);
    editForm.appendChild(checkboxLabel);
    editForm.appendChild(saveButton);

    editButton.addEventListener('click', (e: MouseEvent) => {
      e.preventDefault();
      this.isEditing = true;
      if (this.link) {
        this.link.style.display = 'none';
      }
      editButton.style.display = 'none';
      editForm.style.display = 'flex';
    });

    saveButton.addEventListener('click', (e: MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      this.isEditing = false;
      if (this.link) {
        this.link.href = urlInput.value;
        this.link.style.display = 'inline';
        this.link.target = targetCheckbox.checked ? '_blank' : '_self';
      }
      editButton.style.display = 'inline-flex';
      editForm.style.display = 'none';
    });

    container.appendChild(this.link);
    container.appendChild(editButton);
    container.appendChild(editForm);

    return container;
  }

  /**
   * Gets the current data of the link, including the URL, label, and target behavior.
   * @returns An object containing href, label, and target.
   */
  getLinkData() {
    return {
      href: this.link?.href || '#',
      label: this.link?.innerText || 'Click Here',
      target: this.link?.target || '_self',
    };
  }

  /**
   * Updates the link's URL, label, and target programmatically.
   * @param href - The new URL for the link.
   * @param label - The new text displayed for the link.
   * @param target - The target behavior ('_self' for the same tab, '_blank' for a new tab).
   */
  updateLink(href: string, label: string, target: string = '_self'): void {
    if (this.link) {
      this.link.href = href;
      this.link.innerText = label;
      this.link.target = target;
    }
  }

  /**
   * Checks if the component is currently in editing mode.
   * @returns A boolean indicating whether the component is in editing mode.
   */
  isInEditMode(): boolean {
    return this.isEditing;
  }

  /**
   * Restores the edit functionality for an existing link component
   * @param container - The container element of the link component
   */
  static restore(container: HTMLElement): void {
    // Find necessary elements
    const link = container.querySelector(
      '.link-component-label'
    ) as HTMLAnchorElement;
    const editButton = container.querySelector(
      '.edit-link'
    ) as HTMLButtonElement;
    const editForm = container.querySelector(
      '.edit-link-form'
    ) as HTMLDivElement;
    const saveButton = editForm.querySelector('button') as HTMLButtonElement;
    const urlInput = editForm.querySelector(
      'input[type="url"]'
    ) as HTMLInputElement;
    const targetCheckbox = editForm.querySelector(
      'input[type="checkbox"]'
    ) as HTMLInputElement;

    if (
      !link ||
      !editButton ||
      !editForm ||
      !saveButton ||
      !urlInput ||
      !targetCheckbox
    ) {
      console.error('Required elements not found');
      return;
    }

    // Set initial display states
    link.style.display = 'inline';
    editButton.style.display = 'inline-flex';
    editForm.style.display = 'none';

    // Clone and replace the edit button to remove existing listeners
    const newEditButton = editButton.cloneNode(true) as HTMLButtonElement;
    const newSaveButton = saveButton.cloneNode(true) as HTMLButtonElement;

    editButton.parentNode?.replaceChild(newEditButton, editButton);
    saveButton.parentNode?.replaceChild(newSaveButton, saveButton);

    // Add new click event listener
    newEditButton.addEventListener('click', (e: MouseEvent) => {
      e.preventDefault();
      link.style.display = 'none';
      newEditButton.style.display = 'none';
      editForm.style.display = 'flex';
    });

    // Add new save button click event listener
    newSaveButton.addEventListener('click', (e: MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      link.href = urlInput.value;
      link.style.display = 'inline';
      link.target = targetCheckbox.checked ? '_blank' : '_self';
      newEditButton.style.display = 'inline-flex';
      editForm.style.display = 'none';
    });
  }
}



================================================
File: src/components/TableComponent.ts
================================================
export class TableComponent {
  create(
    rowCount: number,
    columnCount: number,
    isPreview: boolean = false
  ): HTMLElement {
    // Create a container for the table
    const container = document.createElement('div');
    container.classList.add('table-component');

    // Create the table element
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';

    // Generate table rows and cells
    for (let i = 0; i < rowCount; i++) {
      const row = document.createElement('tr');
      for (let j = 0; j < columnCount; j++) {
        const cell = document.createElement('td');
        cell.textContent = `R${i + 1}C${j + 1}`;
        cell.style.border = '1px solid #000';
        cell.style.padding = '8px';
        row.appendChild(cell);
      }
      table.appendChild(row);
    }

    // Add table to container
    container.appendChild(table);

    // Add buttons only if not in preview mode
    if (!isPreview) {
      const buttonContainer = document.createElement('div');
      buttonContainer.classList.add('button-container'); // Add a class for styling
      buttonContainer.style.marginTop = '10px';
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '10px';

      // Add Row button
      const addRowButton = document.createElement('button');
      addRowButton.textContent = 'Add Row';
      addRowButton.addEventListener('click', () => this.addRow(table));
      buttonContainer.appendChild(addRowButton);

      // Add Column button
      const addColumnButton = document.createElement('button');
      addColumnButton.textContent = 'Add Column';
      addColumnButton.addEventListener('click', () => this.addColumn(table));
      buttonContainer.appendChild(addColumnButton);

      container.appendChild(buttonContainer);
    }

    return container;
  }

  addRow(table: HTMLTableElement): void {
    const rowCount = table.rows.length;
    const columnCount = table.rows[0]?.cells.length || 0;
    const row = document.createElement('tr');

    for (let i = 0; i < columnCount; i++) {
      const cell = document.createElement('td');
      cell.textContent = `R${rowCount + 1}C${i + 1}`;
      cell.style.border = '1px solid #000';
      cell.style.padding = '8px';
      row.appendChild(cell);
    }

    table.appendChild(row);
  }

  addColumn(table: HTMLTableElement): void {
    const rowCount = table.rows.length;

    for (let i = 0; i < rowCount; i++) {
      const cell = document.createElement('td');
      cell.textContent = `R${i + 1}C${table.rows[i].cells.length + 1}`;
      cell.style.border = '1px solid #000';
      cell.style.padding = '8px';
      table.rows[i].appendChild(cell);
    }
  }

  /**
   * Sets the total number of rows in the table. Adds or removes rows as needed.
   * Preserves existing content where possible.
   * @param table The HTMLTableElement to modify.
   * @param targetRowCount The desired total number of rows.
   */
  setRowCount(table: HTMLTableElement, targetRowCount: number): void {
    if (!table) return;

    const currentRowCount = table.rows.length;
    const currentColumnCount = table.rows[0]?.cells.length || 0; // Assuming uniform columns

    if (targetRowCount < 0) targetRowCount = 0; // Prevent negative rows

    if (targetRowCount > currentRowCount) {
      // Add rows
      for (let i = currentRowCount; i < targetRowCount; i++) {
        const row = document.createElement('tr');
        for (let j = 0; j < currentColumnCount; j++) {
          const cell = document.createElement('td');
          cell.textContent = `R${i + 1}C${j + 1}`;
          cell.style.border = '1px solid #000';
          cell.style.padding = '8px';
          row.appendChild(cell);
        }
        table.appendChild(row);
      }
    } else if (targetRowCount < currentRowCount) {
      // Remove rows
      for (let i = currentRowCount - 1; i >= targetRowCount; i--) {
        table.deleteRow(i);
      }
    }
  }

  /**
   * Sets the total number of columns in the table. Adds or removes columns as needed.
   * Preserves existing content where possible.
   * @param table The HTMLTableElement to modify.
   * @param targetColumnCount The desired total number of columns.
   */
  setColumnCount(table: HTMLTableElement, targetColumnCount: number): void {
    if (!table || table.rows.length === 0) return; // No rows to modify

    const currentRowCount = table.rows.length;
    const currentColumnCount = table.rows[0].cells.length; // Assuming uniform columns

    if (targetColumnCount < 0) targetColumnCount = 0; // Prevent negative columns

    for (let i = 0; i < currentRowCount; i++) {
      const row = table.rows[i];
      if (targetColumnCount > currentColumnCount) {
        // Add columns
        for (let j = currentColumnCount; j < targetColumnCount; j++) {
          const cell = document.createElement('td');
          cell.textContent = `R${i + 1}C${j + 1}`;
          cell.style.border = '1px solid #000';
          cell.style.padding = '8px';
          row.appendChild(cell);
        }
      } else if (targetColumnCount < currentColumnCount) {
        // Remove columns
        for (let j = currentColumnCount - 1; j >= targetColumnCount; j--) {
          row.deleteCell(j);
        }
      }
    }
  }

  /**
   * Converts the first row of a table into a header row.
   *
   * This function takes an HTML table element as input and modifies its first row.
   * It replaces each `<td>` element in the first row with a `<th>` element,
   * preserving the content and attributes of the original `<td>` elements.
   *
   * @param table The HTMLTableElement to modify.
   * @returns void
   */

  createHeder(table: HTMLTableElement): void {
    if (!table || table.rows.length === 0) return;

    const firstRow = table.rows[0];
    for (let i = 0; i < firstRow.cells.length; i++) {
      const tdElement = firstRow.cells[i];
      const thElement = document.createElement('th');
      thElement.innerHTML = tdElement.innerHTML;
      for (const attr of Array.from(tdElement.attributes)) {
        thElement.setAttribute(attr.name, attr.value);
      }
      tdElement.parentNode?.replaceChild(thElement, tdElement);
    }
  }
  /**
   * This method helps to restore the functionality of the buttons present within
   * table component container
   * This method comes to handy when you need to restore the saved page or doing
   * undo redo frequently.
   * @param container
   * @returns void
   */
  static restore(container: HTMLElement): void {
    const instance = new TableComponent();
    // Find the table element
    const table = container.querySelector('table');
    if (!table) {
      console.error('No table found in container');
      return;
    }

    // Find existing buttons
    const buttonContainer = container.querySelector('.button-container');
    if (!buttonContainer) {
      console.error('No button container found');
      return;
    }

    // Get the buttons
    const buttons = buttonContainer.querySelectorAll('button');
    buttons.forEach(button => {
      // Remove existing event listeners
      const newButton = button.cloneNode(true) as HTMLButtonElement;
      button.parentNode?.replaceChild(newButton, button);

      // Add new event listeners based on button text
      if (newButton.textContent === 'Add Row') {
        newButton.addEventListener('click', () =>
          instance.addRow(table as HTMLTableElement)
        );
      } else if (newButton.textContent === 'Add Column') {
        newButton.addEventListener('click', () =>
          instance.addColumn(table as HTMLTableElement)
        );
      }
    });
  }
}



================================================
File: src/components/TextComponent.ts
================================================
export class TextComponent {
  private text: string;

  constructor(text: string = 'Sample Text') {
    this.text = text; // Default text value
  }

  create(): HTMLElement {
    const element = document.createElement('div');
    element.innerText = this.text; // Use dynamic text passed in constructor
    element.contentEditable = 'true'; // Enable inline editing
    element.classList.add('text-component');
    return element;
  }

  setText(newText: string): void {
    this.text = newText;
  }
}



================================================
File: src/components/ThreeColumnContainer.ts
================================================
import { MultiColumnContainer } from '../services/MultiColumnContainer';

export class ThreeColumnContainer extends MultiColumnContainer {
  constructor() {
    super(3, 'threeCol-component');
  }
}



================================================
File: src/components/TwoColumnContainer.ts
================================================
import { MultiColumnContainer } from '../services/MultiColumnContainer';

export class TwoColumnContainer extends MultiColumnContainer {
  constructor() {
    super(2, 'twoCol-component');
  }
}



================================================
File: src/components/VideoComponent.ts
================================================
export class VideoComponent {
  private captureStateHandler: () => void;
  constructor(captureStateHandler: () => void) {
    this.captureStateHandler = captureStateHandler;
  }
  create(src: string | null = null): HTMLElement {
    const container = document.createElement('div');
    container.classList.add('video-component');

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'video/*';
    fileInput.style.display = 'none';
    fileInput.addEventListener('change', event => {
      this.handleFileChange(event, container);
      this.captureStateHandler();
    });

    const uploadText = document.createElement('div');
    uploadText.classList.add('upload-text');
    uploadText.innerText = src ? '' : 'Upload Video';

    const videoElement = document.createElement('video');
    videoElement.controls = true;
    videoElement.style.width = '100%';
    videoElement.style.height = '100%';
    videoElement.style.display = src ? 'block' : 'none';

    if (src) {
      videoElement.src = src;
    }

    const pencilButton = document.createElement('button');
    pencilButton.innerHTML = '🖊️';
    pencilButton.classList.add('pencil-button');
    pencilButton.addEventListener('click', () => fileInput.click());

    container.appendChild(uploadText);
    container.appendChild(fileInput);
    container.appendChild(videoElement);
    container.appendChild(pencilButton);

    return container;
  }

  handleFileChange(event: Event, container: HTMLElement): void {
    const fileInput = event.target as HTMLInputElement;
    const file = fileInput.files ? fileInput.files[0] : null;

    if (file && file.type.startsWith('video/')) {
      const reader = new FileReader();
      reader.onload = () => {
        const videoElement = container.querySelector(
          'video'
        ) as HTMLVideoElement;
        const uploadText = container.querySelector(
          '.upload-text'
        ) as HTMLElement;
        videoElement.src = reader.result as string;
        videoElement.style.display = 'block';
        uploadText.style.display = 'none';
      };
      reader.readAsDataURL(file);
    } else {
      alert('Please upload a valid video file.');
    }
  }
}



================================================
File: src/components/index.ts
================================================
export { TextComponent } from './TextComponent';
export { ImageComponent } from './ImageComponent';
export { VideoComponent } from './VideoComponent';
export { ButtonComponent } from './ButtonComponent';
export { HeaderComponent } from './HeaderComponent';
export { ContainerComponent } from './ContainerComponent';
export { TwoColumnContainer } from './TwoColumnContainer';
export { ThreeColumnContainer } from './ThreeColumnContainer';
export { TableComponent } from './TableComponent';
export { LinkComponent } from './LinkComponent';



================================================
File: src/icons/svgs.ts
================================================
export const svgs = {
  desktop: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M2 6C2 4.34315 3.34315 3 5 3H19C20.6569 3 22 4.34315 22 6V15C22 16.6569 20.6569 18 19 18H13V19H15C15.5523 19 16 19.4477 16 20C16 20.5523 15.5523 21 15 21H9C8.44772 21 8 20.5523 8 20C8 19.4477 8.44772 19 9 19H11V18H5C3.34315 18 2 16.6569 2 15V6ZM5 5C4.44772 5 4 5.44772 4 6V15C4 15.5523 4.44772 16 5 16H19C19.5523 16 20 15.5523 20 15V6C20 5.44772 19.5523 5 19 5H5Z" fill="#000000"/>
                </svg>`,
  tablet: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M19 12V11.988M4 19H20C21.1046 19 22 18.1046 22 17V7C22 5.89543 21.1046 5 20 5H4C2.89543 5 2 5.89543 2 7V17C2 18.1046 2.89543 19 4 19Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>`,
  mobile: `<svg fill="#000000" width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.461 5H9.539a1.6 1.6 0 0 0-1.601 1.603V25.4A1.6 1.6 0 0 0 9.539 27h12.922c.885 0 1.602-.718 1.602-1.602V6.603A1.603 1.603 0 0 0 22.461 5zm-6.46 20.418a1.022 1.022 0 1 1 1.021-1.021c-.001.634-.46 1.021-1.021 1.021zm6.862-3.501H9.138V7.704h13.725v14.213z"/></svg>`,
  save: `<svg fill="#000000" width="800px" height="800px" viewBox="0 0 1920 1920" xmlns="http://www.w3.org/2000/svg">
                    <path d="M790.706 338.824v112.94H395.412c-31.06 0-56.47 25.3-56.47 56.471v744.509c17.73-6.325 36.592-10.391 56.47-10.391h1129.412c19.877 0 38.738 4.066 56.47 10.39V508.236c0-31.171-25.412-56.47-56.47-56.47h-395.295V338.824h395.295c93.402 0 169.411 76.009 169.411 169.411v1242.353c0 93.403-76.01 169.412-169.411 169.412H395.412C302.009 1920 226 1843.99 226 1750.588V508.235c0-93.402 76.01-169.411 169.412-169.411h395.294Zm734.118 1016.47H395.412c-31.06 0-56.47 25.299-56.47 56.47v338.824c0 31.172 25.41 56.47 56.47 56.47h1129.412c31.058 0 56.47-25.298 56.47-56.47v-338.823c0-31.172-25.412-56.47-56.47-56.47ZM1016.622-.023v880.151l246.212-246.325 79.85 79.85-382.532 382.644-382.645-382.644 79.85-79.85L903.68 880.128V-.022h112.941ZM564.824 1468.235c-62.344 0-112.942 50.71-112.942 112.941s50.598 112.942 112.942 112.942c62.343 0 112.94-50.71 112.94-112.942 0-62.23-50.597-112.94-112.94-112.94Z" fill-rule="evenodd"/>
                </svg>`,
  code: `<svg fill="#000000" height="800px" width="800px" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
  viewBox="0 0 493.525 493.525" xml:space="preserve">
<g id="XMLID_30_">
 <path id="XMLID_32_" d="M430.557,79.556H218.44c21.622,12.688,40.255,29.729,54.859,49.906h157.258
     c7.196,0,13.063,5.863,13.063,13.06v238.662c0,7.199-5.866,13.064-13.063,13.064H191.894c-7.198,0-13.062-5.865-13.062-13.064
     V222.173c-6.027-3.1-12.33-5.715-18.845-7.732c-3.818,11.764-12.105,21.787-23.508,27.781c-2.39,1.252-4.987,2.014-7.554,2.844
     v136.119c0,34.717,28.25,62.971,62.968,62.971h238.663c34.718,0,62.969-28.254,62.969-62.971V142.522
     C493.525,107.806,465.275,79.556,430.557,79.556z"/>
 <path id="XMLID_31_" d="M129.037,175.989c51.419,1.234,96.388,28.283,122.25,68.865c2.371,3.705,6.434,5.848,10.657,5.848
     c1.152,0,2.322-0.162,3.46-0.486c5.377-1.545,9.114-6.418,9.179-12.006c0-0.504,0-1.01,0-1.51
     c0-81.148-64.853-147.023-145.527-148.957V64.155c0-5.492-3.038-10.512-7.879-13.078c-2.16-1.139-4.533-1.707-6.889-1.707
     c-2.94,0-5.848,0.88-8.35,2.584L5.751,120.526C2.162,122.98,0.018,127.041,0,131.394c-0.017,4.338,2.113,8.418,5.687,10.902
     l100.17,69.451c2.518,1.753,5.459,2.631,8.414,2.631c2.355,0,4.696-0.553,6.857-1.676c4.855-2.549,7.909-7.6,7.909-13.092V175.989z
     "/>
</g>
</svg>`,
  view: `<svg width="800px" height="800px" viewBox="0 -0.5 25 25" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M19.5 12.5C19.5 14.985 16.366 17 12.5 17C8.634 17 5.5 14.985 5.5 12.5C5.5 10.015 8.634 8 12.5 8C16.366 8 19.5 10.015 19.5 12.5Z" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M14.25 12.5C14.2716 13.1393 13.9429 13.7395 13.3925 14.0656C12.8422 14.3917 12.1578 14.3917 11.6075 14.0656C11.0571 13.7395 10.7284 13.1393 10.75 12.5C10.7284 11.8607 11.0571 11.2604 11.6075 10.9344C12.1578 10.6083 12.8422 10.6083 13.3925 10.9344C13.9429 11.2604 14.2716 11.8607 14.25 12.5V12.5Z" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>`,
  undo: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M7.53033 3.46967C7.82322 3.76256 7.82322 4.23744 7.53033 4.53033L5.81066 6.25H15C18.1756 6.25 20.75 8.82436 20.75 12C20.75 15.1756 18.1756 17.75 15 17.75H8.00001C7.58579 17.75 7.25001 17.4142 7.25001 17C7.25001 16.5858 7.58579 16.25 8.00001 16.25H15C17.3472 16.25 19.25 14.3472 19.25 12C19.25 9.65279 17.3472 7.75 15 7.75H5.81066L7.53033 9.46967C7.82322 9.76256 7.82322 10.2374 7.53033 10.5303C7.23744 10.8232 6.76256 10.8232 6.46967 10.5303L3.46967 7.53033C3.17678 7.23744 3.17678 6.76256 3.46967 6.46967L6.46967 3.46967C6.76256 3.17678 7.23744 3.17678 7.53033 3.46967Z" fill="#1C274C"/>
            </svg>`,
  redo: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M20 7H9.00001C6.23858 7 4 9.23857 4 12C4 14.7614 6.23858 17 9 17H16M20 7L17 4M20 7L17 10" stroke="#1C274C" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>`,
  reset: `<svg width="800px" height="800px" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg">
    
                <g fill="none" fill-rule="evenodd" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" transform="matrix(0 1 1 0 2.5 2.5)">
    
                <path d="m3.98652376 1.07807068c-2.38377179 1.38514556-3.98652376 3.96636605-3.98652376 6.92192932 0 4.418278 3.581722 8 8 8s8-3.581722 8-8-3.581722-8-8-8"/>
    
                <circle cx="8" cy="8" fill="#000000" r="2"/>
    
                <path d="m4 1v4h-4" transform="matrix(1 0 0 -1 0 6)"/>
    
                </g>
    
                </svg>`,
  button: `<svg width="800px" height="800px" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    
                    <rect x="0" fill="none" width="20" height="20"/>
    
                    <g>
    
                    <path d="M17 5H3c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm1 7c0 .6-.4 1-1 1H3c-.6 0-1-.4-1-1V7c0-.6.4-1 1-1h14c.6 0 1 .4 1 1v5z"/>
    
                    </g>
    
                    </svg>`,
  header: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7.55228 5 8 5.44772 8 6V11.5H16V6C16 5.44772 16.4477 5 17 5C17.5523 5 18 5.44772 18 6V12.5V19C18 19.5523 17.5523 20 17 20C16.4477 20 16 19.5523 16 19V13.5H8V19C8 19.5523 7.55228 20 7 20C6.44772 20 6 19.5523 6 19V12.5V6C6 5.44772 6.44772 5 7 5Z" fill="#000000"/>
                        </svg>`,
  image: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect width="24" height="24" fill="white"/>
            <path d="M21 16V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V18M21 16V4C21 3.44772 20.5523 3 20 3H4C3.44772 3 3 3.44772 3 4V18M21 16L15.4829 12.3219C15.1843 12.1228 14.8019 12.099 14.4809 12.2595L3 18" stroke="#000000" stroke-linejoin="round"/>
            <circle cx="8" cy="9" r="2" stroke="#000000" stroke-linejoin="round"/>
            </svg>`,
  video: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" fill="#000"/>
                <polygon points="10,8 16,12 10,16" fill="#ffffff"/>
                </svg>`,
  container: `<svg fill="#000000" width="800px" height="800px" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg" id="memory-box-outer-light-dashed-all"><path d="M4 0V2H2V4H0V0H4M2 6V10H0V6H2M2 12V16H0V12H2M2 18V20H4V22H0V18H2M6 0H10V2H6V0M12 0H16V2H12V0M18 0H22V4H20V2H18V0M18 22V20H20V18H22V22H18M16 22H12V20H16V22M10 22H6V20H10V22M20 6H22V10H20V6M20 12H22V16H20V12Z" /></svg>`,
  text: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M4 4C4 3.44772 4.44772 3 5 3H19C19.5523 3 20 3.44772 20 4V6C20 6.55228 19.5523 7 19 7C18.4477 7 18 6.55228 18 6V5H13V19H15C15.5523 19 16 19.4477 16 20C16 20.5523 15.5523 21 15 21H9C8.44772 21 8 20.5523 8 20C8 19.4477 8.44772 19 9 19H11V5H6V6C6 6.55228 5.55228 7 5 7C4.44772 7 4 6.55228 4 6V4Z" fill="#000000"/>
            </svg>`,
  hyperlink: `<svg 
                      xmlns="http://www.w3.org/2000/svg" 
                      width="18" 
                      height="18" 
                      viewBox="0 0 24 24">
                      <title>Hyperlink</title>
                      <path fill="currentColor" d="M14.78 3.653a3.936 3.936 0 1 1 5.567 5.567l-3.627 3.627a3.936 3.936 0 0 1-5.88-.353a.75.75 0 0 0-1.18.928a5.436 5.436 0 0 0 8.12.486l3.628-3.628a5.436 5.436 0 1 0-7.688-7.688l-3 3a.75.75 0 0 0 1.06 1.061z"/>
                      <path fill="currentColor" d="M7.28 11.153a3.936 3.936 0 0 1 5.88.353a.75.75 0 0 0 1.18-.928a5.436 5.436 0 0 0-8.12-.486L2.592 13.72a5.436 5.436 0 1 0 7.688 7.688l3-3a.75.75 0 1 0-1.06-1.06l-3 3a3.936 3.936 0 0 1-5.567-5.568z"/>
                  </svg>`,
  twocol: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20H12M12 4H18C19.1046 4 20 4.89543 20 6V18C20 19.1046 19.1046 20 18 20H12M12 4V20" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>`,

  threecol: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9.33333 20H5C4.44772 20 4 19.5523 4 19V5C4 4.44772 4.44772 4 5 4H9.33333M9.33333 20V4M9.33333 20H14.6667M9.33333 4H14.6667M14.6667 4H19C19.5523 4 20 4.44772 20 5V19C20 19.5523 19.5523 20 19 20H14.6667M14.6667 4V20" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>`,
  table: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M4 5C4 4.44772 4.44772 4 5 4H19C19.5523 4 20 4.44772 20 5V19C20 19.5523 19.5523 20 19 20H5C4.44772 20 4 19.5523 4 19V5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M9 4V20" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M15 4V20" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M4 9H20" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M4 15H20" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>`,
  landing: `<svg version="1.1" id="Icons" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
           viewBox="0 0 32 32" xml:space="preserve">
            <style type="text/css">
                .st0{fill:none;stroke:#000000;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;}
                .st1{fill:none;stroke:#000000;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;}
                .st2{fill:none;stroke:#000000;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:5.2066,0;}
            </style>
            <line class="st0" x1="3" y1="11" x2="29" y2="11"/>
            <line class="st0" x1="7" y1="8" x2="7" y2="8"/>
            <line class="st0" x1="10" y1="8" x2="10" y2="8"/>
            <line class="st0" x1="13" y1="8" x2="13" y2="8"/>
            <rect x="3" y="5" class="st0" width="26" height="22"/>
            <rect x="6" y="14" class="st0" width="10" height="10"/>
            <rect x="19" y="21" class="st0" width="7" height="3"/>
            <line class="st0" x1="20" y1="15" x2="26" y2="15"/>
            <line class="st0" x1="23" y1="18" x2="26" y2="18"/>
            <polyline class="st0" points="6,22 12,19 16,22 "/>
            <line class="st0" x1="9" y1="17" x2="9" y2="17"/>
            </svg>`,

  delete: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 12V17" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M14 12V17" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M4 7H20" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M6 10V18C6 19.6569 7.34315 21 9 21H15C16.6569 21 18 19.6569 18 18V10" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M9 5C9 3.89543 9.89543 3 11 3H13C14.1046 3 15 3.89543 15 5V7H9V5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>`,

  close: `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M6.99486 7.00636C6.60433 7.39689 6.60433 8.03005 6.99486 8.42058L10.58 12.0057L6.99486 15.5909C6.60433 15.9814 6.60433 16.6146 6.99486 17.0051C7.38538 17.3956 8.01855 17.3956 8.40907 17.0051L11.9942 13.4199L15.5794 17.0051C15.9699 17.3956 16.6031 17.3956 16.9936 17.0051C17.3841 16.6146 17.3841 15.9814 16.9936 15.5909L13.4084 12.0057L16.9936 8.42059C17.3841 8.03007 17.3841 7.3969 16.9936 7.00638C16.603 6.61585 15.9699 6.61585 15.5794 7.00638L11.9942 10.5915L8.40907 7.00636C8.01855 6.61584 7.38538 6.61584 6.99486 7.00636Z" fill="#0F0F0F"/>
                </svg>`,
  edit: `<svg fill="#000000" height="800px" width="800px" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
    viewBox="0 0 348.882 348.882" xml:space="preserve">
<g>
   <path d="M333.988,11.758l-0.42-0.383C325.538,4.04,315.129,0,304.258,0c-12.187,0-23.888,5.159-32.104,14.153L116.803,184.231
       c-1.416,1.55-2.49,3.379-3.154,5.37l-18.267,54.762c-2.112,6.331-1.052,13.333,2.835,18.729c3.918,5.438,10.23,8.685,16.886,8.685
       c0,0,0.001,0,0.001,0c2.879,0,5.693-0.592,8.362-1.76l52.89-23.138c1.923-0.841,3.648-2.076,5.063-3.626L336.771,73.176
       C352.937,55.479,351.69,27.929,333.988,11.758z M130.381,234.247l10.719-32.134l0.904-0.99l20.316,18.556l-0.904,0.99
       L130.381,234.247z M314.621,52.943L182.553,197.53l-20.316-18.556L294.305,34.386c2.583-2.828,6.118-4.386,9.954-4.386
       c3.365,0,6.588,1.252,9.082,3.53l0.419,0.383C319.244,38.922,319.63,47.459,314.621,52.943z"/>
   <path d="M303.85,138.388c-8.284,0-15,6.716-15,15v127.347c0,21.034-17.113,38.147-38.147,38.147H68.904
       c-21.035,0-38.147-17.113-38.147-38.147V100.413c0-21.034,17.113-38.147,38.147-38.147h131.587c8.284,0,15-6.716,15-15
       s-6.716-15-15-15H68.904c-37.577,0-68.147,30.571-68.147,68.147v180.321c0,37.576,30.571,68.147,68.147,68.147h181.798
       c37.576,0,68.147-30.571,68.147-68.147V153.388C318.85,145.104,312.134,138.388,303.85,138.388z"/>
</g>
</svg>`,
};



================================================
File: src/navbar/CreateNavbar.ts
================================================
// Function to create the navbar
import { svgs } from '../icons/svgs';
export function createNavbar() {
  const navbar = document.createElement('nav');
  navbar.id = 'preview-navbar';

  const icons = {
    desktop: svgs.desktop,
    tablet: svgs.tablet,
    mobile: svgs.mobile,
    save: svgs.save,
    export: svgs.code,
    view: svgs.view,
    undo: svgs.undo,
    redo: svgs.redo,
    reset: svgs.reset,
  };

  // Array of button data with only titles
  const leftButtons = [
    { id: 'preview-desktop', icon: icons.desktop, title: 'Preview in Desktop' },
    { id: 'preview-tablet', icon: icons.tablet, title: 'Preview in Tablet' },
    { id: 'preview-mobile', icon: icons.mobile, title: 'Preview in Mobile' },
    { id: 'undo-btn', icon: icons.undo, title: 'Undo button' },
    { id: 'redo-btn', icon: icons.redo, title: 'Redo button' },
  ];

  const rightButtons = [
    { id: 'view-btn', icon: icons.view, title: 'View' },
    { id: 'save-btn', icon: icons.save, title: 'Save Layout' },
    { id: 'reset-btn', icon: icons.reset, title: 'Reset' },
    { id: 'export-btn', icon: icons.export, title: 'Export' },
  ];

  const leftContainer = document.createElement('div');
  leftContainer.classList.add('left-buttons');

  leftButtons.forEach(({ id, icon, title }) => {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('preview-btn');
    button.title = title;

    // Insert the SVG directly as innerHTML
    button.innerHTML = icon;

    const svgElement = button.querySelector('svg');
    if (svgElement) {
      svgElement.classList.add('nav-icon');
    }
    leftContainer.appendChild(button);
  });

  const centerText = document.createElement('div');
  centerText.classList.add('center-text');
  centerText.textContent = 'Page Builder';

  const rightContainer = document.createElement('div');
  rightContainer.classList.add('right-buttons');

  rightButtons.forEach(({ id, icon, title }) => {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('preview-btn');
    button.title = title;

    // Insert the SVG directly as innerHTML
    button.innerHTML = icon;

    const svgElement = button.querySelector('svg');
    if (svgElement) {
      svgElement.classList.add('nav-icon');
    }
    rightContainer.appendChild(button);
  });

  navbar.appendChild(leftContainer);
  navbar.appendChild(centerText);
  navbar.appendChild(rightContainer);

  return navbar;
}



================================================
File: src/services/HTMLGenerator.ts
================================================
import { Canvas } from '../canvas/Canvas';

export class HTMLGenerator {
  private canvas: Canvas;
  private styleElement: HTMLStyleElement;

  constructor(canvas: Canvas) {
    this.canvas = canvas;
    this.styleElement = document.createElement('style');
    document.head.appendChild(this.styleElement);
  }

  generateHTML(): string {
    const canvasElement = document.getElementById('canvas');
    if (!canvasElement) {
      console.warn('Canvas element not found!');
      return this.getBaseHTML(); // Return base HTML if canvas is not found
    }

    // Clone the canvas element to avoid modifying the original
    const cleanCanvas = canvasElement.cloneNode(true) as HTMLElement;

    // Remove unwanted attributes and elements from all children
    this.cleanupElements(cleanCanvas);

    // Create a full HTML document
    // Use the canvas's outerHTML to include the element itself
    return this.getBaseHTML(cleanCanvas.innerHTML);
  }

  private getBaseHTML(bodyContent: string = 'children'): string {
    return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Page Builder</title>
    <style>
      ${this.generateCSS()}
    </style>
 </head>
        <body>
            <div id="page" class="home">
            ${bodyContent}
            </div>
        </body>
      </html>`;
  }

  private cleanupElements(element: HTMLElement) {
    const attributesToRemove = ['contenteditable', 'draggable', 'style'];
    const classesToRemove = [
      'component-controls',
      'delete-icon',
      'component-label',
      'column-label',
      'editable-component',
      'resizers',
      'resizer',
      'upload-btn',
      'component-resizer',
      'drop-preview',
      'edit-link-form',
      'edit-link',
    ];

    Array.from(element.children).forEach(child => {
      const childElement = child as HTMLElement;

      // Remove specified attributes
      attributesToRemove.forEach(attr => {
        childElement.removeAttribute(attr);
      });

      // Remove specified classes
      classesToRemove.forEach(classToRemove => {
        childElement.classList.remove(classToRemove);
      });

      // Remove input elements
      const inputElements = element.querySelectorAll('input');
      inputElements.forEach(input => input.remove());

      // Remove specific child elements
      const elementsToRemove = childElement.querySelectorAll(
        '.component-controls, .delete-icon, .component-label,.column-label, .resizers, .resizer, .drop-preview, .upload-btn, component-resizer,.edit-link, .edit-link-form'
      );
      elementsToRemove.forEach(el => el.remove());

      // Recursively clean up nested elements
      if (childElement.children.length > 0) {
        this.cleanupElements(childElement);
      }
    });
  }

  generateCSS(): string {
    const canvasElement = document.getElementById('canvas');
    if (!canvasElement) return '';
    const backgroundColor = canvasElement
      ? window
          .getComputedStyle(canvasElement)
          .getPropertyValue('background-color')
      : 'rgb(255, 255, 255)'; // Fallback to white if canvas is not found

    const styles: string[] = [];
    // Global and .home styles
    styles.push(`
      body, html {
          margin: 0;
          padding: 0;
          width: 100%;
          height: 100%;
          box-sizing: border-box;
      }
      .home {
          display: flex;
          justify-content: center;
          align-items: center;
          width: 100%;
          min-height:100vh;
          background-color: ${backgroundColor};
          margin: 0;
      }
      `);

    const elements = canvasElement.querySelectorAll('*');

    const stylesToCapture = [
      'position',
      'top',
      'left',
      'right',
      'bottom',
      'width',
      'height',
      'min-width',
      'min-height',
      'max-width',
      'max-height',
      'margin',
      'padding',
      'background-color',
      'background-image',
      'border',
      'border-radius',
      'transform',
      'opacity',
      'z-index',
      'display',
      'flex-direction',
      'justify-content',
      'align-items',
      'flex-wrap',
      'font-size',
      'font-weight',
      'color',
      'text-align',
      'line-height',
      'font-family',
    ];

    const classesToExclude = [
      'component-controls',
      'delete-icon',
      'component-label',
      'resizers',
      'resizer',
      'upload-btn',
      'edit-link-form',
      'edit-link',
    ];

    elements.forEach(component => {
      // Skip excluded elements
      if (classesToExclude.some(cls => component.classList.contains(cls))) {
        return;
      }

      const computedStyles = window.getComputedStyle(component);
      const componentStyles: string[] = [];

      stylesToCapture.forEach(prop => {
        const value = computedStyles.getPropertyValue(prop);
        if (value && value !== 'none' && value !== '') {
          // Exclude "resize" property with any value
          if (prop === 'resize') return;

          componentStyles.push(`${prop}: ${value};`);
        }
      });

      const selector = this.generateUniqueSelector(component);

      if (componentStyles.length > 0) {
        styles.push(`
        ${selector} {
          ${componentStyles.join('\n  ')}
        }`);
      }
    });

    return styles.join('\n');
  }

  private generateUniqueSelector(element: Element): string {
    if (element.id) {
      return `#${element.id}`;
    }

    if (element.className) {
      return `.${element.className.split(' ').join('.')}`;
    }

    // Create a tag-based selector with index for uniqueness
    const parent = element.parentElement;
    if (parent) {
      const siblings = Array.from(parent.children);
      const index = siblings.indexOf(element);
      return `${element.tagName.toLowerCase()}:nth-child(${index + 1})`;
    }

    return element.tagName.toLowerCase();
  }

  applyCSS(css: string) {
    this.styleElement.textContent = css;
  }
}



================================================
File: src/services/HistoryManager.ts
================================================
import { Canvas } from '../canvas/Canvas';

export class HistoryManager {
  private undoStack: any[] = [];
  private redoStack: any[] = [];
  private canvas: Canvas;

  constructor(canvas: Canvas) {
    this.canvas = canvas;
  }

  /**
   * Capture the current state of the canvas with getState method.
   * Clears the redo stack when a new action is made.
   * Limits the undo stack size to a maximum of 20 entries.
   */
  captureState() {
    const state = Canvas.getState();

    if (state.length > 0) {
      const lastState = this.undoStack[this.undoStack.length - 1];

      // Only capture the state if it's different from the last state
      if (JSON.stringify(state) !== JSON.stringify(lastState)) {
        this.undoStack.push(state);

        // Limit the undo stack size to a maximum of 20 entries
        if (this.undoStack.length > 20) {
          this.undoStack.shift();
        }

        // Clear the redo stack as a new action is made
        this.redoStack = [];
      }
    } else {
      console.warn('No valid state to capture.');
    }
  }

  /**
   * Undo the last action.
   * Save the current state to the redo stack before undoing.
   * Restores the previous state if available.
   */
  undo() {
    if (this.undoStack.length > 1) {
      const currentState = this.undoStack.pop();
      this.redoStack.push(currentState);

      const previousState = this.undoStack[this.undoStack.length - 1];
      Canvas.restoreState(previousState);
    } else if (this.undoStack.length === 1) {
      const initialState = this.undoStack.pop();
      this.redoStack.push(initialState);

      // Load existing layout from local storage and render, if any else empty the canvas
      const savedState = Canvas.jsonStorage.load();
      savedState ? Canvas.restoreState(savedState) : Canvas.restoreState([]);
    } else {
      console.warn('No more actions to undo.');
    }
  }

  /**
   * Redo the last undone action.
   * Save the current state to the undo stack before redoing.
   * Restores the next state if available.
   */
  redo() {
    if (this.redoStack.length > 0) {
      const nextState = this.redoStack.pop();
      this.undoStack.push(nextState);

      Canvas.restoreState(nextState);
    } else {
      console.warn('No more actions to redo.');
    }
  }
}



================================================
File: src/services/JSONStorage.ts
================================================
export class JSONStorage {
  save(data: object) {
    localStorage.setItem('pageLayout', JSON.stringify(data));
  }

  load(): object | null {
    const data = localStorage.getItem('pageLayout');
    return data ? JSON.parse(data) : null;
  }
  remove() {
    localStorage.removeItem('pageLayout');
  }
}



================================================
File: src/services/MultiColumnContainer.ts
================================================
import { Canvas } from '../canvas/Canvas';
import { ImageComponent } from '../components/ImageComponent';

/**
 * MultiColumnContainer is a reusable container class that dynamically creates a flexible number of columns based on the specified column count.
 * It handles the creation of the container element, dynamically creates columns, sets up drag-and-drop functionality,
 * and applies necessary styles for layout. It also manages the event handling for dropping components into columns.
 */
export class MultiColumnContainer {
  protected element: HTMLElement;
  protected columnCount: number;

  constructor(
    columnCount: number,
    className: string = `${columnCount}Col-component`
  ) {
    this.columnCount = columnCount;
    this.element = document.createElement('div');
    this.element.classList.add(className);
    this.element.setAttribute('draggable', 'true');

    // Create columns dynamically based on columnCount
    for (let i = 1; i <= columnCount; i++) {
      const column = this.createColumn(`column-${i}`);
      this.element.appendChild(column);
    }

    // Add styles
    this.addStyles(className);

    // Add event listeners
    this.initializeEventListeners();
  }

  /**
   * Creates an individual column inside the container with a given class name.
   * The column's width is dynamically adjusted based on the number of columns in the container.
   */
  private createColumn(className: string): HTMLElement {
    const column = document.createElement('div');
    column.classList.add('column', className);
    column.setAttribute('draggable', 'true');
    column.style.width = `${100 / this.columnCount}%`; // Equal width for all columns
    return column;
  }

  /**
   * Initializes event listeners for the container element.
   * It listens for dragover and drop events to handle the drag-and-drop functionality.
   */
  private initializeEventListeners(): void {
    this.element.addEventListener('dragover', event => event.preventDefault());
    this.element.addEventListener('drop', this.onDrop.bind(this));
  }

  /**
   * Handles the drop event when a component is dropped onto a column.
   * It appends the component to the target column, generates unique IDs for the component and column,
   * and updates the component and column with labels for easy identification.
   * It also captures the state in the history manager for undo/redo functionality.
   */
  protected onDrop(event: DragEvent): void {
    event.preventDefault();
    event.stopPropagation();

    const componentType = event.dataTransfer?.getData('component-type');
    if (!componentType) return;

    const component = Canvas.createComponent(componentType);
    if (!component) return;

    const targetColumn = event.target as HTMLElement;

    if (targetColumn && targetColumn.classList.contains('column')) {
      targetColumn.appendChild(component);

      const parentId = this.element.id;

      // Determine the column-specific suffix dynamically
      const columnIndex = Array.from(
        targetColumn.parentElement!.children
      ).indexOf(targetColumn);
      const columnSuffix = `c${columnIndex}`;

      const newColumnClassName = `${parentId}-${columnSuffix}`;
      targetColumn.id = newColumnClassName;
      targetColumn.classList.add(newColumnClassName);

      let columnLabel = targetColumn.querySelector(
        '.column-label'
      ) as HTMLSpanElement;
      if (!columnLabel) {
        columnLabel = document.createElement('span');
        columnLabel.className = 'column-label';
        targetColumn.appendChild(columnLabel);
      }
      columnLabel.textContent = newColumnClassName;

      const uniqueComponentClass = Canvas.generateUniqueClass(
        componentType,
        true,
        newColumnClassName
      );
      component.classList.add(uniqueComponentClass);

      component.id = uniqueComponentClass;

      let componentLabel = component.querySelector(
        '.component-label'
      ) as HTMLSpanElement;
      if (!componentLabel) {
        componentLabel = document.createElement('span');
        componentLabel.className = 'component-label';
        component.appendChild(componentLabel);
      }
      componentLabel.textContent = uniqueComponentClass;

      Canvas.historyManager.captureState();
    }
  }

  /**
   * Adds the required styles for the container and its columns.
   * It dynamically creates a style element and applies flexbox-based layout styles,
   * ensuring that the columns are evenly distributed and visually styled with hover effects.
   */
  private addStyles(className: string): void {
    const style = document.createElement('style');
    style.textContent = `
      .${className} {
        display: flex;
        width: 97%;
        min-width: 100px;
        min-height: 100px;
      }
      .column {
        flex-grow: 1;
        min-width: 50px;
        border: 1px dashed #ddd;
        padding: 10px;
        position: relative;
      }
      .column:hover {
        outline: 1px solid #3498db;
        background: #f5f5f5;
      }
    `;
    document.head.appendChild(style);
  }

  /**
   * Creates and returns the container element that holds the columns.
   * This method is called to generate the full container after the columns have been created.
   */
  public create(): HTMLElement {
    return this.element;
  }

  /**
   * Restores a column by reapplying necessary controls to the child components.
   * This includes adding control buttons, making child components draggable,
   * and restoring image uploads if the child is an image component.
   */
  public static restoreColumn(column: HTMLElement): void {
    const columnChildren = column.querySelectorAll('.editable-component');
    columnChildren.forEach((child: any) => {
      Canvas.controlsManager.addControlButtons(child);
      Canvas.addDraggableListeners(child);

      if (child.classList.contains('image-component')) {
        const imageSrc = child.querySelector('img')?.getAttribute('src') || '';
        ImageComponent.restoreImageUpload(child, imageSrc);
      }
    });
  }
}



================================================
File: src/services/ShortcutManager.ts
================================================
import { Canvas } from '../canvas/Canvas';

export class ShortcutManager {
  /**
   * Initializes keyboard shortcuts.
   */
  static init() {
    document.addEventListener('keydown', this.handleKeydown);
  }

  /**
   * Handles keydown events for shortcuts.
   * @param event - The keyboard event.
   */
  private static handleKeydown(event: KeyboardEvent) {
    if (event.ctrlKey || event.metaKey) {
      switch (event.key.toLowerCase()) {
        case 'z': // Undo
          event.preventDefault();
          Canvas.historyManager.undo();
          break;

        case 'y': // Redo
          event.preventDefault();
          Canvas.historyManager.redo();
          break;

        default:
          break;
      }
    }
  }
}



================================================
File: src/sidebar/ConfigSidebar.ts
================================================
import { Canvas } from '../canvas/Canvas';

export class Sidebar {
  private canvas: Canvas;

  constructor(canvas: Canvas) {
    this.canvas = canvas;
  }

  init() {
    const sidebar = document.getElementById('sidebar')!;
    sidebar.addEventListener('click', this.onOptionClick.bind(this));
  }

  onOptionClick(event: MouseEvent) {
    const target = event.target as HTMLElement;
    if (target.classList.contains('config-option')) {
      this.applyConfig(target.dataset.option!);
    }
  }

  private applyConfig(option: string) {
    const selectedComponent = document.querySelector(
      '.selected'
    ) as HTMLElement;
    if (selectedComponent) {
      switch (option) {
        case 'color':
          selectedComponent.style.color = 'blue';
          break;
        case 'padding':
          selectedComponent.style.padding = '10px';
          break;
      }
    }
  }
}



================================================
File: src/sidebar/CreateSidebar.ts
================================================
import { svgs } from '../icons/svgs';
export function createSidebar(dynamicComponents: DynamicComponents) {
  // We have default values if there is no custom components are specified within parameters
  if (
    !dynamicComponents ||
    (dynamicComponents.Basic.length === 0 &&
      dynamicComponents.Extra.length === 0 &&
      Object.keys(dynamicComponents.Custom).length === 0)
  ) {
    dynamicComponents = {
      Basic: [
        'button',
        'header',
        'text',
        'image',
        'video',
        'container',
        'twoCol',
        'threeCol',
        'table',
        'link',
      ],
      // Add portfolio for version 2
      Extra: ['landingpage'],
      Custom: {},
    };
  }
  const sidebar = document.getElementById('sidebar')!;
  if (!sidebar) {
    console.error('Sidebar element not found');
    return;
  }

  // Define your components, icons, and titles as before using it
  const icons: { [key: string]: string } = {
    button: svgs.button,
    header: svgs.header,
    image: svgs.image,
    video: svgs.video,
    text: svgs.text,
    container: svgs.container,
    twoCol: svgs.twocol,
    threeCol: svgs.threecol,
    table: svgs.table,
    // portfolio: 'dist/icons/portfolio.png',
    landingpage: svgs.landing,
    link: svgs.hyperlink,
  };

  const titles: { [key: string]: string } = {
    button: 'Button',
    header: 'Header',
    image: 'Image',
    video: 'Link Video',
    text: 'Text',
    container: 'Container',
    twoCol: 'Two Column Layout',
    threeCol: 'Three Column Layout',
    table: 'Table',
    // portfolio: 'Portfolio Template',
    landingpage: 'Landing Page Template',
    link: 'Link',
  };

  // Create the Templates menu section
  const templatesMenu = document.createElement('div');
  templatesMenu.classList.add('menu');

  // Depending upon the config object of the dynamic components, it will add components to the sidebar
  Object.entries(dynamicComponents).forEach(([category, components]) => {
    const categoryMenu = document.createElement('div');
    categoryMenu.classList.add('category');

    const categoryHeading = document.createElement('h4');
    categoryHeading.classList.add('categoryHeading');
    categoryHeading.innerHTML = category;
    categoryMenu.prepend(categoryHeading);

    // Handling standard dynamic components (Basic and Extra)
    if (Array.isArray(components)) {
      components.forEach((componentId: string) => {
        const iconElement = document.createElement('div');
        iconElement.classList.add('draggable');
        iconElement.id = componentId;
        iconElement.setAttribute('draggable', 'true');
        iconElement.setAttribute('data-component', componentId);

        const customTitle = titles[componentId] || `Drag to add ${componentId}`;
        iconElement.setAttribute('title', customTitle);

        // Add SVG as innerHTML
        if (icons[componentId]) {
          iconElement.innerHTML = icons[componentId];

          // Optionally style the SVG
          const svgElement = iconElement.querySelector('svg');
          if (svgElement) {
            svgElement.classList.add('component-icon');
          }
        } else {
          console.warn(`Icon not found for component: ${componentId}`);
        }

        categoryMenu.appendChild(iconElement);
      });
    }
    // Handling Custom components (which is an object)
    else if (category === 'Custom' && typeof components === 'object') {
      Object.entries(components).forEach(([keyName, config]) => {
        const iconElement = document.createElement('div');
        iconElement.classList.add('draggable', 'custom-component');
        iconElement.id = keyName;
        iconElement.setAttribute('draggable', 'true');
        iconElement.setAttribute('data-component', keyName);

        // Handle the config object properly - could be old format or new format
        if (typeof config === 'string') {
          // Handle legacy format where config is just the tag name string
          iconElement.setAttribute('data-tag-name', config);
          iconElement.setAttribute('title', `Drag to add ${keyName}`);

          // Create element with first letter of the key name
          const letterSpan = document.createElement('span');
          letterSpan.classList.add('custom-component-letter');
          letterSpan.textContent = keyName.charAt(0).toUpperCase();
          iconElement.appendChild(letterSpan);
        } else {
          // Handling new format with CustomComponentConfig
          const { component, svg, title, settings }: any = config;

          iconElement.setAttribute('data-tag-name', component);
          iconElement.setAttribute('title', title || `Drag to add ${keyName}`);

          // Store custom settings as a JSON string
          if (settings && settings.length > 0) {
            iconElement.setAttribute(
              'data-custom-settings',
              JSON.stringify(settings)
            );
          }

          if (svg) {
            // Using provided SVG
            iconElement.innerHTML = svg;

            // Style the SVG
            const svgElement = iconElement.querySelector('svg');
            if (svgElement) {
              svgElement.classList.add('component-icon');
            }
          } else {
            // Fallback to first letter if no SVG provided
            const letterSpan = document.createElement('span');
            letterSpan.classList.add('custom-component-letter');
            letterSpan.textContent = keyName.charAt(0).toUpperCase();
            iconElement.appendChild(letterSpan);
          }
        }

        categoryMenu.appendChild(iconElement);
      });
    }

    templatesMenu.appendChild(categoryMenu);
  });

  sidebar.appendChild(templatesMenu);
}



================================================
File: src/sidebar/CustomizationSidebar.ts
================================================
import { Canvas } from '../canvas/Canvas';
import { debounce } from '../utils/utilityFunctions';
import LayersViewController from './LayerViewController';
import { TableComponent } from '../components/TableComponent'; // Import the TableComponent

// Ensure this interface matches the structure from your types.d.ts
interface CustomComponentSetting {
  name: string;
  functionName: string;
}

export class CustomizationSidebar {
  private static sidebarElement: HTMLElement;
  private static controlsContainer: HTMLElement; // This will be the CSS properties panel
  private static componentNameHeader: HTMLElement;
  private static closeButton: HTMLElement;
  private static layersModeToggle: HTMLDivElement;
  private static layersView: HTMLDivElement;
  private static layersViewController: LayersViewController;
  private static expandConfiguration: HTMLDivElement;
  private static functionsPanel: HTMLDivElement; // New: Panel for functionality settings
  private static selectedComponent: HTMLElement | null = null; // To keep track of the currently selected component

  static init() {
    this.sidebarElement = document.getElementById('customization')!;
    this.controlsContainer = document.getElementById('controls')!; // CSS controls
    this.componentNameHeader = document.getElementById('component-name')!;
    this.closeButton = document.createElement('button');

    if (!this.sidebarElement || !this.controlsContainer) {
      console.error('CustomizationSidebar: Required elements not found.');
      return;
    }
    // Initialize LayersViewController
    this.layersViewController = new LayersViewController();

    // Create expandible menu (Customize CSS, Settings Panel)
    this.expandConfiguration = document.createElement('div');
    this.expandConfiguration.className = 'expand-config';
    this.expandConfiguration.id = 'expand-config';
    this.expandConfiguration.innerHTML = `
        <button id="css-tab" title="Customize CSS" class="dropdown-btn active">Customize CSS</button>
        <button id="functionalities-tab" title="Settings Panel" class="dropdown-btn">Settings Panel</button>
    `;

    // Create functionality panel
    this.functionsPanel = document.createElement('div'); // Initialize the functions panel
    this.functionsPanel.id = 'functions-panel';
    this.functionsPanel.className = 'dropdown-panel';
    this.functionsPanel.style.display = 'none'; // Initially hidden

    // Create layers mode toggle (Customize, Layers)
    this.layersModeToggle = document.createElement('div');
    this.layersModeToggle.className = 'layers-mode-toggle';
    this.layersModeToggle.innerHTML = `
        <button id="customize-tab" title="Customize" class="active">⚙️</button>
        <button id="layers-tab" title="Layers"> ☰ </button>
    `;

    // Insert layers toggle before component name
    this.sidebarElement.insertBefore(
      this.layersModeToggle,
      this.componentNameHeader
    );

    // Insert expand config (with both buttons) after component name
    this.sidebarElement.insertBefore(
      this.expandConfiguration,
      this.componentNameHeader.nextSibling
    );

    // Insert CSS panel (controlsContainer) and Functionalities panel
    this.sidebarElement.appendChild(this.controlsContainer); // ControlsContainer is the CSS panel
    this.sidebarElement.appendChild(this.functionsPanel); // Functionalities panel

    // Set initial display for controlsContainer to block
    this.controlsContainer.style.display = 'block';

    // Add event listeners to toggle panels
    const cssTabBtn = document.getElementById('css-tab')!;
    const funcTabBtn = document.getElementById('functionalities-tab')!;

    cssTabBtn.addEventListener('click', () => {
      this.controlsContainer.style.display = 'block';
      this.functionsPanel.style.display = 'none';
      cssTabBtn.classList.add('active');
      funcTabBtn.classList.remove('active');
      if (this.selectedComponent) {
        this.populateCssControls(this.selectedComponent); // Repopulate CSS controls for selected component
      }
    });

    funcTabBtn.addEventListener('click', () => {
      this.functionsPanel.style.display = 'block';
      this.controlsContainer.style.display = 'none';
      funcTabBtn.classList.add('active');
      cssTabBtn.classList.remove('active');
      if (this.selectedComponent) {
        this.populateFunctionalityControls(this.selectedComponent); // Populate functionality controls
      }
    });

    // Create layers view (This element is now within the sidebar)
    this.layersView = document.createElement('div');
    this.layersView.id = 'layers-view';
    this.layersView.className = 'layers-view hidden';
    this.sidebarElement.appendChild(this.layersView); // Append to sidebar directly

    // Add event listeners for tab switching (Customize vs Layers)
    const customizeTab = this.layersModeToggle.querySelector('#customize-tab')!;
    const layersTab = this.layersModeToggle.querySelector('#layers-tab')!;

    customizeTab.addEventListener('click', () => this.switchToCustomizeMode());
    layersTab.addEventListener('click', () => this.switchToLayersMode());

    // Add the close button to the sidebar
    this.sidebarElement.appendChild(this.closeButton);
    this.closeButton.textContent = '×'; // Close button symbol
    this.closeButton.classList.add('close-button');

    // Add the event listener to hide the sidebar when the close button is clicked
    this.closeButton.addEventListener('click', () => {
      this.hideSidebar();
    });
  }

  // --- Tab Switching Logic ---
  private static switchToCustomizeMode() {
    const customizeTab = document.getElementById('customize-tab')!;
    const layersTab = document.getElementById('layers-tab')!;
    const layersView = document.getElementById('layers-view')!;
    const componentName = document.getElementById('component-name')!;
    const expandConfig = document.getElementById('expand-config')!;

    customizeTab.classList.add('active');
    layersTab.classList.remove('active');
    layersView.style.display = 'none'; // Hide layers view

    expandConfig.style.display = 'flex'; // Show the expand-config container

    // Ensure the CSS tab is active by default and its panel is shown
    const cssTabBtn = document.getElementById('css-tab')!;
    const funcTabBtn = document.getElementById('functionalities-tab')!;

    cssTabBtn.classList.add('active'); // Activate CSS tab
    funcTabBtn.classList.remove('active'); // Deactivate Functionalities tab

    this.controlsContainer.style.display = 'block'; // Show CSS panel
    this.functionsPanel.style.display = 'none'; // Hide Functionalities panel

    componentName.style.display = 'block'; // Show component name header
    // Repopulate CSS controls based on the selected component (if any)
    if (this.selectedComponent) {
      this.populateCssControls(this.selectedComponent);
    }
  }

  private static switchToLayersMode() {
    const customizeTab = document.getElementById('customize-tab')!;
    const layersTab = document.getElementById('layers-tab')!;
    const layersView = document.getElementById('layers-view')!;
    const componentName = document.getElementById('component-name')!;
    const expandConfig = document.getElementById('expand-config')!;

    layersTab.classList.add('active');
    customizeTab.classList.remove('active');

    expandConfig.style.display = 'none'; // Hide expand-config in layers mode

    // Hide both dropdown panels
    this.controlsContainer.style.display = 'none';
    this.functionsPanel.style.display = 'none';
    document.getElementById('css-tab')?.classList.remove('active');
    document.getElementById('functionalities-tab')?.classList.remove('active');

    layersView.style.display = 'block'; // Show layers view
    componentName.style.display = 'none'; // Hide component name header

    LayersViewController.updateLayersView();
  }

  // --- Sidebar Display Management ---
  static showSidebar(componentId: string) {
    const component = document.getElementById(componentId);
    if (!component) {
      console.error(`Component with ID "${componentId}" not found.`);
      return;
    }
    this.selectedComponent = component; // Store the selected component

    this.sidebarElement.style.display = 'block';
    this.componentNameHeader.textContent = `Component: ${componentId}`;

    // By default, activate and populate the CSS tab when sidebar is shown
    const cssTabBtn = document.getElementById('css-tab')!;
    const funcTabBtn = document.getElementById('functionalities-tab')!;

    if (
      !cssTabBtn.classList.contains('active') &&
      !funcTabBtn.classList.contains('active')
    ) {
      cssTabBtn.click(); // Simulate click to activate CSS tab and populate it
    } else if (cssTabBtn.classList.contains('active')) {
      this.populateCssControls(component);
    } else if (funcTabBtn.classList.contains('active')) {
      this.populateFunctionalityControls(component);
    }
  }

  static hideSidebar() {
    if (this.sidebarElement) {
      this.sidebarElement.style.display = 'none';
      this.selectedComponent = null; // Clear selected component
    }
  }

  // --- Populate CSS Controls ---
  private static populateCssControls(component: HTMLElement) {
    this.controlsContainer.innerHTML = ''; // Clear previous controls
    const styles = getComputedStyle(component);
    const isCanvas = component.id.toLowerCase() === 'canvas';

    // Re-create all CSS controls
    this.createSelectControl('Display', 'display', styles.display || 'block', [
      'block',
      'inline',
      'inline-block',
      'flex',
      'grid',
      'none',
    ]);
    if (!isCanvas) {
      this.createControl('Width', 'width', 'number', component.offsetWidth, {
        min: 0,
        max: 1000,
        unit: 'px',
      });
      this.createControl('Height', 'height', 'number', component.offsetHeight, {
        min: 0,
        max: 1000,
        unit: 'px',
      });
      this.createControl(
        'Margin',
        'margin',
        'number',
        parseInt(styles.margin) || 0,
        {
          min: 0,
          max: 1000,
          unit: 'px',
        }
      );
      this.createControl(
        'Padding',
        'padding',
        'number',
        parseInt(styles.padding) || 0,
        {
          min: 0,
          max: 1000,
          unit: 'px',
        }
      );
    }

    this.createControl(
      'Background Color',
      'background-color', // Changed ID to be more specific
      'color',
      styles.backgroundColor
    );
    this.createSelectControl('Text Alignment', 'alignment', styles.textAlign, [
      'left',
      'center',
      'right',
    ]);

    this.createSelectControl('Font Family', 'font-family', styles.fontFamily, [
      'Arial',
      'Verdana',
      'Helvetica',
      'Times New Roman',
      'Georgia',
      'Courier New',
      'sans-serif',
      'serif',
    ]);
    this.createControl(
      'Font Size',
      'font-size',
      'number',
      parseInt(styles.fontSize) || 16,
      {
        min: 0,
        max: 100,
        unit: 'px',
      }
    );

    this.createControl(
      'Text Color',
      'text-color',
      'color',
      styles.color || '#000000'
    );

    this.createControl(
      'Border Width',
      'border-width',
      'number',
      parseInt(styles.borderWidth) || 0,
      {
        min: 0,
        max: 20,
        unit: 'px',
      }
    );

    this.createSelectControl(
      'Border Style',
      'border-style',
      styles.borderStyle || 'none',
      [
        'none',
        'solid',
        'dashed',
        'dotted',
        'double',
        'groove',
        'ridge',
        'inset',
        'outset',
      ]
    );
    this.createControl(
      'Border Color',
      'border-color',
      'color',
      styles.borderColor || '#000000'
    );

    // Update color input value to hex for background color
    const bgColorInput = document.getElementById(
      'background-color'
    ) as HTMLInputElement;
    if (bgColorInput) {
      bgColorInput.value = CustomizationSidebar.rgbToHex(
        styles.backgroundColor
      );
    }
    // Update color input value to hex for text color
    const textColorInput = document.getElementById(
      'text-color'
    ) as HTMLInputElement;
    if (textColorInput) {
      textColorInput.value = CustomizationSidebar.rgbToHex(styles.color);
    }
    // Update color input value to hex for border color
    const borderColorInput = document.getElementById(
      'border-color'
    ) as HTMLInputElement;
    if (borderColorInput) {
      borderColorInput.value = CustomizationSidebar.rgbToHex(
        styles.borderColor
      );
    }

    this.addListeners(component); // Re-attach listeners for CSS controls
  }

  // --- Populate Functionality Controls (New) ---
  private static populateFunctionalityControls(component: HTMLElement) {
    this.functionsPanel.innerHTML = ''; // Clear previous controls in the functions panel

    // Handle standard components with specific functionalities (e.g., TableComponent)
    if (component.classList.contains('table-component')) {
      const table = component.querySelector('table');
      if (table) {
        const currentRows = table.rows.length;
        const currentCols = table.rows[0]?.cells.length || 0; // Handle empty table

        // Rows control
        const rowsWrapper = document.createElement('div');
        rowsWrapper.classList.add('control-wrapper');
        rowsWrapper.innerHTML = `
                  <label for="table-rows">Number of Rows:</label>
                  <div class="input-wrapper">
                    <input type="number" id="table-rows" value="${currentRows}" min="0">
                  </div>
              `;
        this.functionsPanel.appendChild(rowsWrapper);

        const rowsInput = rowsWrapper.querySelector(
          '#table-rows'
        ) as HTMLInputElement;
        rowsInput.addEventListener(
          'input',
          debounce(() => {
            const newRowCount = parseInt(rowsInput.value);
            if (!isNaN(newRowCount)) {
              // Allow 0 rows
              const tableInstance = new TableComponent(); // Create an instance to call its methods
              tableInstance.setRowCount(table, newRowCount);
              Canvas.historyManager.captureState(); // Capture state after modification
            }
          }, 300)
        ); // Debounce for performance

        // Columns control
        const colsWrapper = document.createElement('div');
        colsWrapper.classList.add('control-wrapper');
        colsWrapper.innerHTML = `
                  <label for="table-cols">Number of Columns:</label>
                  <div class="input-wrapper">
                    <input type="number" id="table-cols" value="${currentCols}" min="0">
                  </div>
              `;
        this.functionsPanel.appendChild(colsWrapper);

        const colsInput = colsWrapper.querySelector(
          '#table-cols'
        ) as HTMLInputElement;
        colsInput.addEventListener(
          'input',
          debounce(() => {
            const newColCount = parseInt(colsInput.value);
            if (!isNaN(newColCount)) {
              // Allow 0 columns
              const tableInstance = new TableComponent(); // Create an instance
              tableInstance.setColumnCount(table, newColCount);
              Canvas.historyManager.captureState(); // Capture state
            }
          }, 300)
        );

        //header row
        const headerWrapper = document.createElement('div');
        headerWrapper.classList.add('control-wrapper');
        headerWrapper.innerHTML = `
          <label for="table-header">Create Header:</label>
          <div class="input-wrapper">
            <input type="checkbox" id="table-header"  min="0">
          </div
        `;
        this.functionsPanel.appendChild(headerWrapper);
        const headerInput = headerWrapper.querySelector(
          '#table-header'
        ) as HTMLInputElement;
        headerInput.addEventListener(
          'input',
          debounce(() => {
            const isHeader = headerInput.checked;
            if (isHeader) {
              const tableInstance = new TableComponent();
              tableInstance.createHeder(table);
              Canvas.historyManager.captureState();
            }
          }, 300)
        );
      }
    } else if (component.classList.contains('custom-component')) {
      console.log('DEBUG: Component is custom-component');
      console.log('DEBUG: Component id:', component.id);
      console.log('DEBUG: Component classes:', Array.from(component.classList));

      // Check multiple ways to get settings
      let customSettingsAttr = component.getAttribute('data-custom-settings');
      console.log(
        'DEBUG: data-custom-settings from getAttribute:',
        customSettingsAttr
      );

      // Alternative: try to infer settings from component type
      if (!customSettingsAttr) {
        // Extract component type from class name
        const componentType = Array.from(component.classList)
          .find(cls => cls.endsWith('-component'))
          ?.replace('-component', '');

        console.log('DEBUG: Inferred component type:', componentType);

        // Try to get settings from a global registry or window object
        // This assumes your PageBuilder exposes the custom components config
        if (componentType && (window as any).customComponents) {
          const customComponents = (window as any).customComponents;
          if (
            customComponents[componentType] &&
            customComponents[componentType].settings
          ) {
            customSettingsAttr = JSON.stringify(
              customComponents[componentType].settings
            );
            console.log(
              'DEBUG: Got settings from window registry:',
              customSettingsAttr
            );
          }
        }
      }

      if (customSettingsAttr) {
        try {
          const customSettings: CustomComponentSetting[] =
            JSON.parse(customSettingsAttr);

          if (customSettings.length > 0) {
            customSettings.forEach(setting => {
              const settingButton = document.createElement('button');
              settingButton.classList.add('custom-setting-button');
              settingButton.textContent = setting.name;
              settingButton.addEventListener('click', () => {
                console.log(
                  'DEBUG: Custom setting button clicked:',
                  setting.functionName
                );

                // Get the ID of the currently selected component on the canvas
                const selectedComponentOnCanvasId = component.id; // This is the ID of the wrapper element, e.g., 'customrating1'

                if (!selectedComponentOnCanvasId) {
                  console.error('No selected component ID found for dispatch.');
                  return;
                }

                // Create the custom event
                const event = new CustomEvent(
                  'pagebuilder:custom-setting-action',
                  {
                    detail: {
                      functionName: setting.functionName,
                      targetComponentId: selectedComponentOnCanvasId, // <--- IMPORTANT: Include the target component's ID
                    },
                    bubbles: true, // Allow event to bubble up the DOM tree (important for document listeners)
                    composed: true, // Allow event to cross Shadow DOM boundaries
                  }
                );

                console.log(
                  'DEBUG: Dispatching event globally for ID:',
                  selectedComponentOnCanvasId,
                  event
                );

                // Dispatch the event to the global document object
                document.dispatchEvent(event); // <--- IMPORTANT: Dispatch to document
                Canvas.historyManager.captureState();
              });
              this.functionsPanel.appendChild(settingButton);
            });
          }
        } catch (e) {
          console.error('DEBUG: Error parsing data-custom-settings JSON:', e);
          this.functionsPanel.innerHTML =
            '<p>Error loading custom settings.</p>';
        }
      } else {
        console.log('DEBUG: No custom settings found');
        this.functionsPanel.innerHTML =
          '<p>No custom settings available for this component.</p>';
      }
    } else {
      console.log('DEBUG: Component is not a custom component');
      this.functionsPanel.innerHTML =
        '<p>No specific settings for this component.</p>';
    }
  }

  // --- Utility Methods (rgbToHex, createControl, createSelectControl, addListeners) ---
  static rgbToHex(rgb: string): string {
    const result = rgb.match(
      /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.?\d*))?\)$/
    );
    if (!result) return rgb; // If the format is not matched, return the original string

    const r = parseInt(result[1], 10);
    const g = parseInt(result[2], 10);
    const b = parseInt(result[3], 10);

    // Ensure it's in the correct hex format
    return `#${((1 << 24) | (r << 16) | (g << 8) | b).toString(16).slice(1).toUpperCase()}`;
  }

  private static createControl(
    label: string,
    id: string,
    type: string,
    value: string | number,
    attributes: Record<string, string | number> = {}
  ) {
    const wrapper = document.createElement('div');
    wrapper.classList.add('control-wrapper');

    // Check if the control is a color input or a number input
    const isNumber = type === 'number';

    // Format value for number inputs and add a unit dropdown
    if (isNumber && attributes.unit) {
      const unit = attributes.unit;
      wrapper.innerHTML = `
                <label for="${id}">${label}:</label>
                <div class="input-wrapper">
                  <input type="${type}" id="${id}" value="${value}">
                  <select id="${id}-unit">
                      <option value="px" ${unit === 'px' ? 'selected' : ''}>px</option>
                      <option value="rem" ${unit === 'rem' ? 'selected' : ''}>rem</option>
                      <option value="vh" ${unit === 'vh' ? 'selected' : ''}>vh</option>
                      <option value="%" ${unit === '%' ? 'selected' : ''}>%</option>
                  </select>
                </div
            `;
    } else {
      // For color inputs, add a text input to display/edit hex code
      wrapper.innerHTML = `
        <label for="${id}">${label}:</label>
        <div class="input-wrapper">
          <input type="color" id="${id}" value="${value}">
          <input type="text" id="${id}-value" style="font-size: 0.8rem; width: 80px; margin-left: 8px;" value="${value}">
        </div>
      `;
    }

    const input = wrapper.querySelector('input') as HTMLInputElement;
    const unitSelect = wrapper.querySelector(
      `#${id}-unit`
    ) as HTMLSelectElement;

    if (input) {
      Object.keys(attributes).forEach(key => {
        input.setAttribute(key, attributes[key].toString());
      });
    }

    // If it's a color input, update the hex code display
    const colorInput = wrapper.querySelector(
      `input[type="color"]#${id}`
    ) as HTMLInputElement;
    const hexInput = wrapper.querySelector(`#${id}-value`) as HTMLInputElement;

    if (colorInput) {
      colorInput.addEventListener('input', () => {
        if (hexInput) {
          hexInput.value = colorInput.value; // Update hex code display
        }
      });
    }

    if (hexInput) {
      hexInput.addEventListener('input', () => {
        if (colorInput) {
          colorInput.value = hexInput.value; // Update color input with the new hex code
        }
      });
    }

    this.controlsContainer.appendChild(wrapper);

    // Update value dynamically when unit changes
    if (unitSelect) {
      unitSelect.addEventListener('change', () => {
        const unit = unitSelect.value;
        const currentValue = parseInt(input.value);
        input.value = `${currentValue}${unit}`;
      });
    }
  }

  private static createSelectControl(
    label: string,
    id: string,
    currentValue: string,
    options: string[]
  ) {
    const wrapper = document.createElement('div');
    wrapper.classList.add('control-wrapper');
    const selectOptions = options
      .map(
        option =>
          `<option value="${option}" ${
            option === currentValue ? 'selected' : ''
          }>${option}</option>`
      )
      .join('');
    wrapper.innerHTML = `
                <label for="${id}">${label}:</label>
                <div class="input-wrapper">
                  <select id="${id}">${selectOptions}</select>
                </div>
            `;
    this.controlsContainer.appendChild(wrapper);
  }

  private static addListeners(component: HTMLElement) {
    // Collect all existing input/select elements dynamically
    const controls: { [key: string]: HTMLInputElement | HTMLSelectElement } = {
      width: document.getElementById('width') as HTMLInputElement,
      height: document.getElementById('height') as HTMLInputElement,
      backgroundColor: document.getElementById(
        'background-color'
      ) as HTMLInputElement, // Updated ID
      margin: document.getElementById('margin') as HTMLInputElement,
      padding: document.getElementById('padding') as HTMLInputElement,
      alignment: document.getElementById('alignment') as HTMLSelectElement,
      fontSize: document.getElementById('font-size') as HTMLInputElement,
      textColor: document.getElementById('text-color') as HTMLInputElement,
      borderWidth: document.getElementById('border-width') as HTMLInputElement,
      borderStyle: document.getElementById('border-style') as HTMLSelectElement,
      borderColor: document.getElementById('border-color') as HTMLInputElement,
      display: document.getElementById('display') as HTMLSelectElement,
      fontFamily: document.getElementById('font-family') as HTMLSelectElement,
    };

    const captureStateDebounced = debounce(() => {
      Canvas.historyManager.captureState();
    }, 300);

    // Attach listeners only if the element exists
    controls.width?.addEventListener('input', () => {
      const unit = (document.getElementById('width-unit') as HTMLSelectElement)
        .value;
      component.style.width = `${controls.width.value}${unit}`;
      captureStateDebounced();
    });

    controls.height?.addEventListener('input', () => {
      const unit = (document.getElementById('height-unit') as HTMLSelectElement)
        .value;
      component.style.height = `${controls.height.value}${unit}`;
      captureStateDebounced();
    });

    controls.backgroundColor?.addEventListener('input', () => {
      // Updated ID
      component.style.backgroundColor = controls.backgroundColor.value;
      (
        document.getElementById('background-color-value') as HTMLInputElement
      ).value = controls.backgroundColor.value; // Update hex code display
      captureStateDebounced();
    });
    (
      document.getElementById('background-color-value') as HTMLInputElement
    )?.addEventListener('input', e => {
      const target = e.target as HTMLInputElement;
      component.style.backgroundColor = target.value;
      (document.getElementById('background-color') as HTMLInputElement).value =
        target.value;
      captureStateDebounced();
    });

    controls.margin?.addEventListener('input', () => {
      const unit = (document.getElementById('margin-unit') as HTMLSelectElement)
        .value;
      component.style.margin = `${controls.margin.value}${unit}`;
      captureStateDebounced();
    });

    controls.padding?.addEventListener('input', () => {
      const unit = (
        document.getElementById('padding-unit') as HTMLSelectElement
      ).value;
      component.style.padding = `${controls.padding.value}${unit}`;
      captureStateDebounced();
    });

    controls.alignment?.addEventListener('change', () => {
      component.style.textAlign = controls.alignment.value;
      captureStateDebounced();
    });

    controls.fontSize?.addEventListener('input', () => {
      const unit = (
        document.getElementById('font-size-unit') as HTMLSelectElement
      ).value;
      component.style.fontSize = `${controls.fontSize.value}${unit}`;
      captureStateDebounced();
    });

    controls.textColor?.addEventListener('input', () => {
      component.style.color = controls.textColor.value;
      (document.getElementById('text-color-value') as HTMLInputElement).value =
        controls.textColor.value;
      captureStateDebounced();
    });
    (
      document.getElementById('text-color-value') as HTMLInputElement
    )?.addEventListener('input', e => {
      const target = e.target as HTMLInputElement;
      component.style.color = target.value;
      (document.getElementById('text-color') as HTMLInputElement).value =
        target.value;
      captureStateDebounced();
    });

    controls.borderWidth?.addEventListener('input', () => {
      const unit = (
        document.getElementById('border-width-unit') as HTMLSelectElement
      ).value;
      component.style.borderWidth = `${controls.borderWidth.value}${unit}`;
      captureStateDebounced();
    });

    controls.borderStyle?.addEventListener('change', () => {
      component.style.borderStyle = controls.borderStyle.value;
      captureStateDebounced();
    });

    controls.borderColor?.addEventListener('input', () => {
      component.style.borderColor = controls.borderColor.value;
      (
        document.getElementById('border-color-value') as HTMLInputElement
      ).value = controls.borderColor.value;
      captureStateDebounced();
    });
    (
      document.getElementById('border-color-value') as HTMLInputElement
    )?.addEventListener('input', e => {
      const target = e.target as HTMLInputElement;
      component.style.borderColor = target.value;
      (document.getElementById('border-color') as HTMLInputElement).value =
        target.value;
      captureStateDebounced();
    });

    controls.display?.addEventListener('change', () => {
      component.style.display = controls.display.value;
      captureStateDebounced();
    });

    controls.fontFamily?.addEventListener('change', () => {
      component.style.fontFamily = controls.fontFamily.value;
      captureStateDebounced();
    });
  }

  static getLayersViewController(): LayersViewController {
    return this.layersViewController;
  }
}



================================================
File: src/sidebar/LayerViewController.ts
================================================
import { Canvas } from '../canvas/Canvas'; // Assuming a Canvas management class
import { HTMLGenerator } from '../services/HTMLGenerator';

interface LayerItem {
  id: string;
  children?: LayerItem[];
  isVisible?: boolean;
  isLocked?: boolean;
  depth?: number;
}

class LayersViewController {
  private static layersView: HTMLElement | null = null;
  private static canvasRoot: HTMLElement | null = null;
  private static draggedItem: HTMLElement | null = null;

  constructor(
    layersViewSelector: string = '#layers-view',
    canvasRootSelector: string = '#canvas'
  ) {
    // Ensure elements exist before assignment
    this.initializeElements(layersViewSelector, canvasRootSelector);
  }

  /**
   * Initialize layers view and canvas root elements
   */
  private initializeElements(
    layersViewSelector: string,
    canvasRootSelector: string
  ) {
    // Try to find layers view
    LayersViewController.layersView =
      document.querySelector(layersViewSelector);
    if (!LayersViewController.layersView) {
      // Create layers view if it doesn't exist
      LayersViewController.layersView = document.createElement('div');
      LayersViewController.layersView.id = 'layers-view';
      LayersViewController.layersView.className = 'layers-view';

      // Optional: Add the layers view to the document
      // You might want to append this to a specific container
      document.body.appendChild(LayersViewController.layersView);

      console.warn(`Layers view element created: ${layersViewSelector}`);
    }

    // Try to find canvas root
    LayersViewController.canvasRoot =
      document.querySelector(canvasRootSelector);
    if (!LayersViewController.canvasRoot) {
      console.error(`Canvas root element not found: ${canvasRootSelector}`);
      // Fallback to body if no specific root is found
      LayersViewController.canvasRoot = document.body;
    }
  }

  /**
   * Recursive function to build layer hierarchy from DOM
   */
  private static buildLayerHierarchyFromDOM(
    rootElement: HTMLElement
  ): LayerItem[] {
    const htmlGenerator = new HTMLGenerator(new Canvas());
    const generatedHTML = htmlGenerator.generateHTML();

    // Parse the generated HTML into a DOM tree
    const parser = new DOMParser();
    const doc = parser.parseFromString(generatedHTML, 'text/html');

    // Recursively traverse the DOM to build LayerItem hierarchy
    const traverseDom = (
      element: Element,
      depth: number = 0
    ): LayerItem | null => {
      const htmlElement = element as HTMLElement; // Assert the element is an HTMLElement
      // Skip elements without an `id` attribute
      if (!htmlElement.id) {
        return null;
      }

      const layer: LayerItem = {
        id: htmlElement.id,
        isVisible: htmlElement.style?.display !== 'none', // Check visibility only for HTMLElements
        isLocked: htmlElement.getAttribute('data-locked') === 'true',
        depth,
        children: [],
      };

      Array.from(element.children).forEach(child => {
        const childLayer = traverseDom(child, depth + 1);
        if (childLayer) {
          layer.children!.push(childLayer);
        }
      });

      return layer;
    };

    const rootElements = Array.from(doc.body.children);

    // Build the hierarchy and filter out any `null` layers
    return rootElements
      .map(element => traverseDom(element))
      .filter(layer => layer !== null) as LayerItem[];
  }

  /**
   * Render the layers view with nested structure
   */
  public static updateLayersView() {
    if (!this.layersView || !this.canvasRoot) {
      console.error('Layers view or canvas root not initialized');
      return;
    }

    // Clear existing layers
    this.layersView.innerHTML = '';

    // Build hierarchy from DOM
    const hierarchy = this.buildLayerHierarchyFromDOM(this.canvasRoot);

    // Create layers list
    const layersList = document.createElement('ul');
    layersList.className = 'layers-list';

    // Render layer items
    this.renderLayerItems(layersList, hierarchy);

    // Append to layers view
    this.layersView.appendChild(layersList);
  }

  /**
   * Render layer items recursively
   */
  private static renderLayerItems(
    parentElement: HTMLElement,
    layers: LayerItem[],
    depth: number = 0
  ) {
    const list = document.createElement('ul');
    list.className = 'layer-list';
    parentElement.appendChild(list);

    layers.forEach(layer => {
      // List item to contain everything related to this layer
      const listItem = document.createElement('li');
      listItem.className = 'layer-item-container';
      list.appendChild(listItem);

      // The actual layer item element
      const layerItem = this.createLayerItemElement(layer);
      layerItem.style.paddingLeft = `${depth * 12}px`;
      listItem.appendChild(layerItem);

      // Handle nested children
      if (layer.children && layer.children.length > 0) {
        const expandToggle = document.createElement('span');
        expandToggle.className = 'layer-expand-toggle';
        expandToggle.textContent = '▶';
        layerItem.insertBefore(expandToggle, layerItem.firstChild);

        // Created a container for children
        const childContainer = document.createElement('div');
        childContainer.className = 'child-container';
        childContainer.style.display = 'none';
        listItem.appendChild(childContainer);

        // Recursively render children
        this.renderLayerItems(childContainer, layer.children, depth + 1);

        // Toggle expand/collapse
        expandToggle.addEventListener('click', () => {
          const isExpanded = childContainer.style.display === 'block';

          if (isExpanded) {
            childContainer.style.display = 'none';
            expandToggle.textContent = '▶';
          } else {
            childContainer.style.display = 'block';
            expandToggle.textContent = '▼';
          }
        });
      }
    });
  }

  /**
   * Create a layer item element with advanced interactions
   */
  private static createLayerItemElement(layer: LayerItem): HTMLElement {
    const layerItem = document.createElement('li');
    layerItem.className = 'layer-item';
    layerItem.dataset.layerId = layer.id;

    // Visibility toggle
    const visibilityToggle = document.createElement('span');
    visibilityToggle.className = 'layer-visibility';
    visibilityToggle.innerHTML = layer.isVisible ? '👁️' : '👁️‍🗨️';
    visibilityToggle.addEventListener('click', () =>
      this.toggleLayerVisibility(layer)
    );

    // Layer name with type
    const layerName = document.createElement('span');
    layerName.className = 'layer-name';
    layerName.textContent = `${layer.id}`;
    layerName.addEventListener('click', () => this.selectLayer(layer));

    // Lock toggle
    const lockToggle = document.createElement('span');
    lockToggle.className = 'layer-lock';
    lockToggle.innerHTML = layer.isLocked ? '🔒' : '🔓';
    lockToggle.addEventListener('click', () => this.toggleLayerLock(layer));

    // Drag and drop functionality
    layerItem.draggable = true;
    layerItem.addEventListener('dragstart', e =>
      this.handleDragStart(e, layer)
    );
    layerItem.addEventListener('dragover', this.handleDragOver);
    layerItem.addEventListener('drop', e => this.handleDrop(e, layer));

    // Append elements
    layerItem.appendChild(visibilityToggle);
    layerItem.appendChild(layerName);
    layerItem.appendChild(lockToggle);

    return layerItem;
  }
  /**
   * Toggle layer visibility
   */
  private static toggleLayerVisibility(layer: LayerItem) {
    const component = document.getElementById(layer.id);
    if (!component) return;

    if (component.style.display === 'none') {
      component.style.display = component.dataset.originalDisplay || '';
      layer.isVisible = true;
    } else {
      component.dataset.originalDisplay = component.style.display;
      component.style.display = 'none';
      layer.isVisible = false;
    }

    this.updateLayersView();
  }

  /**
   * Toggle layer lock state
   */
  private static toggleLayerLock(layer: LayerItem) {
    const component = document.getElementById(layer.id);
    if (!component) return;

    layer.isLocked = !layer.isLocked;
    if (layer.isLocked) {
      component.setAttribute('data-locked', 'true');
      component.style.pointerEvents = 'none';
    } else {
      component.removeAttribute('data-locked');
      component.style.pointerEvents = 'auto';
    }

    this.updateLayersView();
  }

  /**
   * Select and customize a specific layer
   */
  private static selectLayer(layer: LayerItem) {
    // Switch to customize mode for the selected layer
    this.switchToCustomizeMode(layer.id);
  }

  /**
   * Drag and drop handling methods
   */
  private static handleDragStart(e: DragEvent, layer: LayerItem) {
    if (e.dataTransfer) {
      e.dataTransfer.setData('text/plain', layer.id);
      this.draggedItem = e.target as HTMLElement;
    }
  }

  private static handleDragOver(e: DragEvent) {
    e.preventDefault();
    e.stopPropagation();
  }

  private static handleDrop(e: DragEvent, targetLayer: LayerItem) {
    e.preventDefault();
    e.stopPropagation();

    if (!e.dataTransfer) return;

    const fromIndex = parseInt(e.dataTransfer?.getData('text/plain') || '-1');
    const toIndex = parseInt(targetLayer.id || '-1');

    // Implement complex reordering logic
    Canvas.reorderComponent(fromIndex, toIndex);

    // Refresh the layers view
    this.updateLayersView();
  }

  /**
   * Switch to layer customization mode
   */
  private static switchToCustomizeMode(layerId: string) {
    // Implement layer-specific customization
    // This could open a sidebar, highlight the component, etc.
    const sidebar = document.getElementById('customize-sidebar');
    if (sidebar) {
      sidebar.style.display = 'block';
      // Load specific layer properties
      this.loadLayerProperties(layerId);
    }
  }

  /**
   * Load layer-specific properties into the sidebar
   */
  private static loadLayerProperties(layerId: string) {
    const component = document.getElementById(layerId);
    if (!component) return;

    // Example: Populate sidebar with component properties
    const propertiesContainer = document.getElementById('layer-properties');
    if (propertiesContainer) {
      propertiesContainer.innerHTML = `
        <h3>Layer Properties: ${layerId}</h3>
        <div>Visibility: ${component.style.display !== 'none' ? 'Visible' : 'Hidden'}</div>
        <div>Locked: ${component.getAttribute('data-locked') === 'true' ? 'Yes' : 'No'}</div>
      `;
    }
  }
}

export default LayersViewController;



================================================
File: src/styles/linkComponent.css
================================================
.link-component {
  border: none;
  display: flex;
  gap: 8px;
  align-items: center;
  padding: 8px;
}

.link-component-label {
  text-decoration: none;
  color: blue;
  font-size: 14px;
  cursor: pointer;
  margin: 10px;
}

.edit-link {
  background-color: transparent !important;
  position: absolute;
  bottom: 1px;
  left: 4px;
  text-decoration: none;
  padding: 4px 8px;
  cursor: pointer;
  display: none;
  border: none;
  font-size: 12px;
}

.link-component:hover .edit-link {
  display: block;
  /* Show the button when hovering over the container */
}

.edit-link-form {
  display: none;
  flex-direction: column;
  gap: 8px;
  padding: 8px;
}

.input-field {
  padding: 4px;
  margin-bottom: 4px;
}

.save-button {
  padding: 4px 8px;
  cursor: pointer;
}

.checkbox-label {
  display: flex;
  align-items: center;
}


================================================
File: src/styles/main.css
================================================
/* Import Google Fonts for better typography */
@import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap");

/* General Styles */
body,
html {
  margin: 0;
  padding: 0;
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  display: flex;
  flex-direction: column;
  background-color: #f8fafc;
  overflow: hidden;
  color: #334155;
}

/* Navbar for preview buttons */
#preview-navbar {
  background-color: #ffffff;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 24px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  border-bottom: 1px solid #e2e8f0;
}

.preview-btn {
  border: 1px solid #e2e8f0;
  padding: 8px 16px;
  cursor: pointer;
  border-radius: 6px;
  background-color: #ffffff;
  color: #64748b;
  font-weight: 500;
  font-size: 14px;
  transition: all 0.2s ease;
}

.preview-btn:hover {
  background-color: #f1f5f9;
  border-color: #cbd5e1;
  color: #475569;
}

.preview-btn:active {
  background-color: #e2e8f0;
}

/* App Container */
#app {
  display: flex;
  height: calc(100vh - 85px);
  background-color: #f8fafc;
  margin: 4px;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Sidebar (Left) */
#sidebar {
  width: 90px;
  flex-shrink: 0;
  background-color: #ffffff;
  padding: 16px 12px;
  overflow-y: auto;
  border-right: 1px solid #e2e8f0;
}

#sidebar h3 {
  text-align: center;
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 20px;
  color: #1e293b;
}

/* Canvas Area */
#canvas {
  width: 100%;
  background-color: #ffffff;
  padding: 20px;
  overflow-y: auto;
  overflow-x: auto;
  box-sizing: border-box;
  background-size: 20px 20px;
  background-image: linear-gradient(to right, #f1f5f9 1px, transparent 1px),
    linear-gradient(to bottom, #f1f5f9 1px, transparent 1px);
}

#customization {
  position: relative;
  display: none;
  right: 0;
  width: 400px;
  background-color: #ffffff;
  box-shadow: -1px 0 3px rgba(0, 0, 0, 0.1);
  padding: 24px; 
  border-left: 1px solid #e2e8f0;
  overflow: auto;
}

/* Draggable Items */
.draggable {
  text-align: center;
  cursor: grab;
  transition: all 0.2s ease;
  box-sizing: border-box;
  max-width: 100%;
  overflow: hidden;

  margin-bottom: 8px;
  font-size: 13px;
  color: #64748b;
}

.draggable:hover {
  background-color: #f1f5f9;
  border-color: #cbd5e1;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.draggable:active {
  cursor: grabbing;
}

/* Component Styles */
.component {
  padding: 16px;
  border: 1px solid #e2e8f0;
  background-color: #ffffff;
  border-radius: 6px;
  cursor: pointer;
  position: absolute;
  transition: all 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.component:hover {
  border-color: #94a3b8;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.text-component {
  font-size: 16px;
  color: #334155;
  line-height: 1.5;
}

.button-component {
  padding: 10px 20px;
  background-color: #3b82f6 !important;
  color: #ffffff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
  font-size: 14px;
}

.button-component:hover {
  background-color: #2563eb;
  transform: translateY(-1px);
}

.header-component {
  font-size: 24px;
  font-weight: 700;
  color: #1e293b;
  margin: 12px 0;
}

.image-component {
  max-width: 100%;
  border-radius: 6px;
  position: relative;
  display: flex;
  justify-content: center;
  width: 300px;
  height: 300px;
  background-color: #f8fafc;
  border: 2px dashed #cbd5e1;
  overflow: hidden;
}

/* Responsive Preview Modes */
.preview-desktop {
  max-width: 100%;
}

.preview-tablet {
  max-width: 768px;
  margin-left: auto;
  margin-right: auto;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.preview-mobile {
  max-width: 375px;
  margin-left: auto;
  margin-right: auto;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Utility Classes */
.hidden {
  display: none;
}

/* Editable components on the canvas */
.editable-component {
  border: 1px solid #e2e8f0;
  padding: 12px;
  margin: 6px;
  border-radius: 6px;
  cursor: text;
  position: relative;
  pointer-events: auto;
  background-color: #ffffff;
  transition: all 0.2s ease;
}

.editable-component:hover {
  border-color: #94a3b8;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.component-resizer {
  overflow: hidden !important;
  resize: both !important;
}

.container-highlight {
  border-color: #3b82f6 !important;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
}

/* Container Component */
.container-component {
  min-height: 100px;
  padding: 16px;
  margin: 6px;
  border: 2px dashed #cbd5e1;
  background-color: #f8fafc;
  display: flex;
  flex-direction: column;
  position: relative;
  pointer-events: auto;
  border-radius: 6px;
}

/* Draggable Icons */
.component-icon {
  width: 35px;
  height: 35px;
  object-fit: contain;

  transition: opacity 0.2s ease;
}

.draggable:hover .component-icon {
  opacity: 1;
}

.nav-icon {
  width: 30px;
  height: 30px;
  object-fit: contain;
  
}

.left-buttons,
.right-buttons {
  display: flex;
  gap: 8px;
}

.center-text {
  font-size: 18px;
  font-weight: 600;
  color: #1e293b;
  text-align: center;
  flex-grow: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}

.component-label,
.column-label {
  position: absolute;
  top: -2px;
  left: 6px;
  background-color: #1e293b;
  color: white;
  font-size: 10px;
  font-weight: 500;
  padding: 2px 6px;
  border-radius: 4px;
  display: none;
  z-index: 10;
  pointer-events: none;
}

.editable-component:hover .component-label {
  display: block;
}

.column:hover .column-label {
  display: block;
}

/* Upload button styling */
.upload-btn {
  position: absolute;
  top: 8px;
  left: 8px;
  background-color: rgba(255, 255, 255, 0.9);
  color: #64748b;
  border: 1px solid #e2e8f0;
  padding: 6px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  display: none;
  z-index: 10;
  transition: all 0.2s ease;
}

.image-component:hover .upload-btn {
  display: block;
}

.upload-btn:hover {
  background-color: #f1f5f9;
  color: #475569;
}

/* Notification styling */
.notification {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background-color: #10b981;
  color: white;
  padding: 12px 20px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
  opacity: 0;
}

.notification.visible {
  opacity: 1;
}

.notification.hidden {
  opacity: 0;
}

/* Dialog styling */
.dialog {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.dialog.hidden {
  display: none;
}

.dialog-content {
  background: white;
  padding: 24px;
  border-radius: 8px;
  text-align: center;
  width: 350px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.dialog-btn {
  margin: 8px 6px;
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  font-size: 14px;
  /* transition: all 0.2s ease; */
}

#dialog-yes {
  background-color: #ef4444;
  color: white;
}

#dialog-yes:hover {
  background-color: #dc2626;
}

#dialog-no {
  background-color: #f1f5f9;
  color: #64748b;
  border: 1px solid #e2e8f0;
}

#dialog-no:hover {
  background-color: #e2e8f0;
}

/* Control panel that appears on hover */
.component-controls {
  display: none;
  position: absolute;
  top: 4px;
  right: 4px;
  align-items: center;
  z-index: 10;
  cursor: pointer;
  background-color: rgba(255, 255, 255, 0.95);
  border-radius: 4px;
  padding: 2px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.delete-icon {
  width: 14px;
  height: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  opacity: 0.7;
}

.delete-icon:hover {
  opacity: 1;
  transform: scale(1.1);
}

.editable-component:hover .component-controls {
  display: flex;
  gap: 2px;
}

/* Control wrapper styling */
.control-wrapper {
  display: flex;
  flex-direction: column;
  margin-bottom: 20px;
  gap: 6px;
  padding: 16px;
  background-color: #f8fafc;
  border-radius: 8px;
  border: 1px solid #f1f5f9;
}

.control-wrapper label {
  display: block;
  margin-bottom: 4px;
  font-size: 13px;
  font-weight: 600;
  color: #374151;
  min-width: auto;
}

/* Fix input field styling - using flex */
.control-wrapper input[type="number"],
.control-wrapper input[type="text"] {
  display: flex;
  padding: 8px 12px;
  font-size: 13px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  background-color: #ffffff;
  transition: all 0.2s ease;
  color: #374151;
}

.control-wrapper select {
  display: flex;
  padding: 8px 12px;
  font-size: 13px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  background-color: #ffffff;
  transition: all 0.2s ease;
  color: #374151;
}

#controls {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.control-wrapper input[type="number"] {
  display: flex;
  width: 60px;
  padding: 6px 8px;
  font-size: 13px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  background-color: #ffffff;
  transition: all 0.2s ease;
}

.control-wrapper input[type="number"]:focus {
  border-color: #3b82f6;
  outline: none;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
}

.input-wrapper{
  display: flex;
  align-items: center;
  gap: 2px;
}

.control-wrapper input[type="color"] {
  width: 32px;
  height: 32px;
  border: 1px solid #d1d5db;
  cursor: pointer;
  border-radius: 4px;
  padding: 0;
  margin: 0;
  overflow: hidden;
  transition: all 0.2s ease;
}

.control-wrapper input[type="color"]:hover {
  border-color: #9ca3af;
}

.control-wrapper select:focus {
  border-color: #3b82f6;
  outline: none;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
}

.control-wrapper.vertical {
  flex-direction: column;
  align-items: flex-start;
}

.control-wrapper.compact {
  gap: 8px;
  padding: 12px;
}

.control-wrapper.compact label {
  min-width: 80px;
  font-size: 12px;
}

#component-name {
  background-color: #f8fafc;
  padding: 12px;
  margin-bottom: 20px;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  font-weight: 600;
  font-size: 13px;
  color: #1e293b;
}

#component-name span {
  font-size: 11px;
  color: #64748b;
  font-weight: 400;
}

#color-value {
  display: inline-block;
  font-size: 12px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  color: #374151;
  padding: 2px 6px;
  background-color: #ffffff;
  font-family: monospace;
}

.close-button {
  position: absolute;
  top: 0;
  left: 0;
  background-color: #f8fafc;
  color: #64748b;
  border: 1px solid #e2e8f0;
  border-radius: 4px;
  width: 28px;
  height: 28px;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: all 0.2s ease;
}

.close-button:hover {
  background-color: #ef4444;
  color: white;
  border-color: #ef4444;
}

/* Modal styles */
#preview-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #ffffff;
  z-index: 9999;
  overflow: auto;
}

#close-modal-btn {
  position: absolute;
  top: 16px;
  left: 16px;
  background-color: #f8fafc;
  color: #64748b;
  border: 1px solid #e2e8f0;
  border-radius: 4px;
  width: 36px;
  height: 36px;
  font-size: 18px;
  cursor: pointer;
  z-index: 10000;
  transition: all 0.2s ease;
}

#close-modal-btn:hover {
  background-color: #f1f5f9;
  color: #475569;
}

.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  justify-content: center;
  align-items: center;
  z-index: 1000;
  transition: all 0.3s ease;
}

.modal.show {
  display: flex;
  opacity: 1;
}

.modal.hide {
  opacity: 0;
}

.modal-content {
  position: relative;
  background: white;
  width: 90%;
  height: 70%;
  max-width: 1000px;
  max-height: 600px;
  display: flex;
  border-radius: 8px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  padding: 20px;
}

.modal-section {
  width: 50%;
  padding: 16px;
}

.modal-section h2 {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 12px;
  color: #1e293b;
}

.code-block {
  width: 95%;
  height: 80%;
  font-family: "JetBrains Mono", "Fira Code", "Courier New", monospace;
  font-size: 12px;
  padding: 16px;
  border-radius: 6px;
  border: 1px solid #e2e8f0;
  color: #e2e8f0;
  background-color: #1e293b;
  overflow-y: auto;
  white-space: pre-wrap;
  line-height: 1.5;
}

.tag {
  color: #7dd3fc;
}
.attribute {
  color: #fbbf24;
}
.string {
  color: #34d399;
}
.property {
  color: #a78bfa;
}
.value {
  color: #fbbf24;
}
.bracket {
  color: #f97316;
}

.button-wrapper {
  display: flex;
  flex-direction: column;
  padding: 20px;
  gap: 8px;
}

.export-btn {
  position: absolute;
  bottom: 20px;
  right: 20px;
  padding: 10px 20px;
  font-size: 14px;
  font-weight: 500;
  color: #fff;
  background-color: #3b82f6;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.export-btn:hover {
  background-color: #2563eb;
  transform: translateY(-1px);
}

/* Table component enhancements */
.table-component {
  background-color: #ffffff;
  border-radius: 6px;
  padding: 12px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.table-component table {
  border-radius: 4px;
  overflow: hidden;
}

.table-component .button-container {
  opacity: 0;
  transition: all 0.2s ease;
  pointer-events: none;
  display: flex;
  gap: 6px;
  margin-top: 8px;
}

.table-component:hover .button-container {
  opacity: 1;
  pointer-events: auto;
}

.table-component button {
  padding: 6px 12px;
  background-color: #3b82f6;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.table-component button:hover {
  background-color: #2563eb;
}

/* Link component styling */
.link-component {
  border: none;
  display: flex;
  gap: 8px;
  align-items: center;
  padding: 8px;
  background-color: #ffffff;
  border-radius: 4px;
}

.link-component-label {
  text-decoration: none;
  color: #3b82f6;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  margin: 0;
  transition: all 0.2s ease;
}

.link-component-label:hover {
  color: #2563eb;
  text-decoration: underline;
}

.edit-link {
  background-color: #f8fafc !important;
  position: absolute;
  bottom: 2px;
  left: 4px;
  padding: 2px 6px;
  cursor: pointer;
  display: none;
  border: 1px solid #e2e8f0;
  font-size: 10px;
  border-radius: 3px;
  color: #64748b;
  font-weight: 500;
  transition: all 0.2s ease;
}

.link-component:hover .edit-link {
  display: block;
}

.edit-link:hover {
  background-color: #f1f5f9 !important;
}

.edit-link-form {
  display: none;
  flex-direction: column;
  gap: 8px;
  padding: 12px;
  background-color: #ffffff;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border: 1px solid #e2e8f0;
}

.edit-link-form input,
.edit-link-form button {
  padding: 6px 10px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.edit-link-form button {
  background-color: #3b82f6;
  color: white;
  border: none;
  cursor: pointer;
  font-weight: 500;
}

.edit-link-form button:hover {
  background-color: #2563eb;
}

/* Category headings */
.categoryHeading {
  margin: 0 0 12px 0;
  text-align: center;
  font-size: 12px;
  font-weight: 600;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Video component */
.video-component {
  width: 300px;
  height: 300px;
  position: relative;
  background-color: #f8fafc;
  display: flex;
  justify-content: center;
  align-items: center;
  border: 2px dashed #cbd5e1;
  border-radius: 6px;
}

.video-component .upload-text {
  color: #64748b;
  text-align: center;
  font-weight: 500;
}

/* Export dropdown */
.export-dropdown {
  display: none;
  position: absolute;
  background-color: #ffffff;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  margin-top: 4px;
  right: 20px;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.export-dropdown.visible {
  display: block;
}

.export-option {
  padding: 10px 16px;
  cursor: pointer;
  border: none;
  background: transparent;
  font-size: 13px;
  font-weight: 500;
  color: #374151;
  transition: all 0.2s ease;
  width: 100%;
  text-align: left;
}

.export-option:hover {
  background-color: #f8fafc;
  color: #1e293b;
}

/* Expandable configuration panels */
.expand-config {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 12px 0;
}

/* Fix dropdown button styling */
.dropdown-btn {
  background-color: #ffffff;
  border: 1px solid #e2e8f0;
  padding: 12px 16px;
  text-align: left;
  font-weight: 600;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.2s ease;
  color: #374151; /* Dark text */
  font-size: 14px;
  width: 100%;
}

.dropdown-btn.active {
  background-color: #f8fafc;
  border-color: #3b82f6;
  color: #3b82f6;
}

.dropdown-btn:hover {
  background-color: #f8fafc;
  border-color: #cbd5e1;
}

.dropdown-panel {
  margin-top: 6px;
  padding: 12px;
  background-color: #ffffff;
  border-left: 3px solid #3b82f6;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

#functions-panel {
  display: flex;
  flex-direction: column;
  margin-top: 6px;
  padding: 12px;
  background-color: #ffffff;
  border-left: 3px solid #3b82f6;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

/* Layer management */
.layers-mode-toggle {
  display: flex;
  margin-bottom: 12px;
  border-radius: 6px;
  overflow: hidden;
  border: 1px solid #e2e8f0;
}

/* Layer management buttons */
.layers-mode-toggle button {
  flex: 1;
  padding: 10px 12px;
  background-color: #f8fafc;
  border: 1px solid #e2e8f0;
  cursor: pointer;
  font-weight: 500;
  color: #374151; /* Dark text instead of white */
  transition: all 0.2s ease;
  font-size: 13px;
}

.layers-mode-toggle button.active {
  background-color: #3b82f6;
  color: white; /* White text only when active */
  border-color: #3b82f6;
}

.layers-mode-toggle button:hover:not(.active) {
  background-color: #f1f5f9;
  color: #1e293b;
}

/* Enhanced layer/tree structure */
.layer-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  list-style: none;
  padding: 10px 2px;
  border: 1px solid #f1f5f9;
  transition: all 0.2s ease;
  background-color: #ffffff;
  margin-bottom: 2px;
  border-radius: 6px;
  font-size: 13px;
  color: #374151;
  min-height: 36px;
}

.layer-item:hover {
  background-color: #f8fafc;
  border-color: #e2e8f0;
  transform: translateX(2px);
}

.layer-children {
  padding: 0 0 0 16px; /* Add left padding for hierarchy */
  margin: 4px 0;
  max-height: 0;
  list-style: none;
  transition: all 0.3s ease;
  overflow: hidden;
  border-left: 2px solid #f1f5f9; /* Visual hierarchy line */
}

.layer-children.expanded {
  max-height: 400px;
  opacity: 1;
}

.layer-expand-toggle {
  cursor: pointer;
  margin-right: 10px;
  padding: 4px 6px;
  border-radius: 4px;
  transition: all 0.2s ease;
  color: #64748b;
  font-size: 14px;
  background-color: #f8fafc;
  border: 1px solid #e2e8f0;
  min-width: 24px;
  text-align: center;
}

.layer-expand-toggle:hover {
  background-color: #f1f5f9;
  color: #374151;
}

/* Drop preview styling */
.drop-preview {
  border: 2px dashed #3b82f6;
  background-color: rgba(59, 130, 246, 0.05);
  position: absolute;
  pointer-events: none;
  display: none;
  border-radius: 4px;
}

.drop-preview.visible {
  display: block;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
  #sidebar {
    width: 90px;
  }

  #customization {
    width: 320px; /* Slightly smaller on medium screens */
  }
}

@media (max-width: 1400px) {
  #customization {
    width: 300px;
  }
}

@media (max-width: 768px) {
  #app {
    flex-direction: column;
    margin: 2px;
  }

  #sidebar {
    width: 100%;
    height: 160px;
    overflow-x: auto;
    display: flex;
    gap: 8px;
    padding: 12px;
  }

  .draggable {
    min-width: 70px;
    margin-bottom: 0;
  }
}



================================================
File: src/templates/LandingPageTemplate.ts
================================================
import {
  ContainerComponent,
  TextComponent,
  ButtonComponent,
} from '../components/index';

export class LandingPageTemplate {
  public create(): HTMLElement {
    const enableDragAndResize = (element: HTMLElement) => {
      let isDragging = false;
      let isResizing = false;
      let startX: number,
        startY: number,
        startWidth: number,
        startHeight: number;
      let initialX = 0,
        initialY = 0; // To store the element's initial position

      // Make element draggable
      element.style.position = 'relative'; // Keep initial layout intact
      element.style.cursor = 'move';

      element.addEventListener('mousedown', e => {
        if (!isResizing) {
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          initialX = parseFloat(element.getAttribute('data-x') || '0');
          initialY = parseFloat(element.getAttribute('data-y') || '0');
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        }
      });

      const onMouseMove = (e: MouseEvent) => {
        if (isDragging) {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;

          // Update transform for smooth movement
          const translateX = initialX + deltaX;
          const translateY = initialY + deltaY;

          element.style.transform = `translate(${translateX}px, ${translateY}px)`;
          element.setAttribute('data-x', translateX.toString());
          element.setAttribute('data-y', translateY.toString());
        }
      };

      const onMouseUp = () => {
        isDragging = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };

      // Add resize handle only to container elements
      if (element.classList.contains('container')) {
        const resizeHandle = document.createElement('div');
        Object.assign(resizeHandle.style, {
          width: '10px',
          height: '10px',
          background: 'blue',
          position: 'absolute',
          right: '0',
          bottom: '0',
          cursor: 'se-resize',
        });
        element.appendChild(resizeHandle);

        resizeHandle.addEventListener('mousedown', e => {
          e.stopPropagation();
          isResizing = true;
          startWidth = element.offsetWidth;
          startHeight = element.offsetHeight;
          startX = e.clientX;
          startY = e.clientY;

          document.addEventListener('mousemove', onResizeMove);
          document.addEventListener('mouseup', onResizeUp);
        });

        const onResizeMove = (e: MouseEvent) => {
          if (isResizing) {
            const newWidth = startWidth + (e.clientX - startX);
            const newHeight = startHeight + (e.clientY - startY);

            element.style.width = `${newWidth}px`;
            element.style.height = `${newHeight}px`;
          }
        };

        const onResizeUp = () => {
          isResizing = false;
          document.removeEventListener('mousemove', onResizeMove);
          document.removeEventListener('mouseup', onResizeUp);
        };
      }
    };

    // Create main container
    const landingPageContainer = new ContainerComponent();
    const containerElement = landingPageContainer.create();
    containerElement.classList.add('container'); // Add a container class for identification
    Object.assign(containerElement.style, {
      width: '100%',
      maxWidth: 'none',
      margin: '0 auto',
      padding: '20px',
      fontFamily: "'Roboto', sans-serif",
    });

    enableDragAndResize(containerElement);

    // Header Section
    const headerSection = new ContainerComponent();
    const headerElement = headerSection.create();
    headerElement.classList.add('container');
    Object.assign(headerElement.style, {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: '40px',
      width: '100%', // Full width
    });
    enableDragAndResize(headerElement);

    const logo = new TextComponent('MyBrand');
    const logoElement = logo.create();
    Object.assign(logoElement.style, {
      fontSize: '24px',
      fontWeight: 'bold',
      color: '#333',
    });

    const navLinks = new ContainerComponent();
    const navElement = navLinks.create();
    navElement.classList.add('container');
    Object.assign(navElement.style, {
      display: 'flex',
      gap: '20px',
    });
    enableDragAndResize(navElement);

    ['Home', 'Features', 'Contact'].forEach(linkText => {
      const link = new TextComponent(linkText);
      const linkElement = link.create();
      Object.assign(linkElement.style, {
        cursor: 'pointer',
        color: '#555',
        textDecoration: 'none',
      });
      navElement.appendChild(linkElement);
    });

    headerElement.appendChild(logoElement);
    headerElement.appendChild(navElement);

    // Hero Section
    const heroSection = new ContainerComponent();
    const heroElement = heroSection.create();
    heroElement.classList.add('container');
    Object.assign(heroElement.style, {
      textAlign: 'center',
      padding: '60px 20px',
      backgroundColor: '#f9f9f9',
      borderRadius: '10px',
      marginBottom: '40px',
    });
    enableDragAndResize(heroElement);

    const heroTitle = new TextComponent('Welcome to My Landing Page');
    const titleElement = heroTitle.create();
    Object.assign(titleElement.style, {
      textAlign: 'center',
      padding: '60px 20px',
      backgroundColor: '#f9f9f9',
      borderRadius: '10px',
      marginBottom: '40px',
      width: '100%',
    });

    const heroSubtitle = new TextComponent(
      'Discover amazing features and build better products with us.'
    );
    const subtitleElement = heroSubtitle.create();
    Object.assign(subtitleElement.style, {
      fontSize: '18px',
      color: '#666',
      marginBottom: '30px',
    });

    const ctaButton = new ButtonComponent();
    const ctaElement = ctaButton.create();
    Object.assign(ctaElement.style, {
      padding: '12px 24px',
      fontSize: '16px',
      color: '#fff',
      backgroundColor: '#007bff',
      border: 'none',
      borderRadius: '5px',
      cursor: 'pointer',
      transition: 'background-color 0.3s',
    });

    ctaElement.addEventListener('mouseenter', () => {
      ctaElement.style.backgroundColor = '#0056b3';
    });
    ctaElement.addEventListener('mouseleave', () => {
      ctaElement.style.backgroundColor = '#007bff';
    });

    heroElement.appendChild(titleElement);
    heroElement.appendChild(subtitleElement);
    heroElement.appendChild(ctaElement);

    // Footer Section
    const footerSection = new ContainerComponent();
    const footerElement = footerSection.create();
    footerElement.classList.add('container');
    Object.assign(footerElement.style, {
      textAlign: 'center',
      padding: '20px',
      marginTop: '40px',
      borderTop: '1px solid #ddd',
    });
    enableDragAndResize(footerElement);

    const footerText = new TextComponent(
      '© 2025 MyBrand. All rights reserved.'
    );
    const footerTextElement = footerText.create();
    Object.assign(footerTextElement.style, {
      fontSize: '14px',
      color: '#999',
    });

    footerElement.appendChild(footerTextElement);

    // Assemble the landing page
    containerElement.appendChild(headerElement);
    containerElement.appendChild(heroElement);
    containerElement.appendChild(footerElement);

    return containerElement;
  }
}



================================================
File: src/templates/UserPortfolioTemplate.ts
================================================
import {
  ImageComponent,
  TextComponent,
  ContainerComponent,
  TwoColumnContainer,
} from '../components/index';

export class UserPortfolioTemplate {
  public create(): HTMLElement {
    // Create main portfolio container using ContainerComponent
    const portfolioContainer = new ContainerComponent();
    const containerElement = portfolioContainer.create();

    // Add styles to portfolio container directly
    const styles = {
      border: 'none',
      padding: '40px',
      margin: '20px auto',
      backgroundColor: '#ffffff',
      borderRadius: '2px',
      boxShadow: '0 12px 50px rgba(0, 0, 0, 0.1)',
      maxWidth: '700px',
      fontFamily: "'Roboto', sans-serif",
      overflow: 'hidden',
      position: 'relative',
      textAlign: 'center',
      transition: 'transform 0.3s ease-in-out',
    };

    Object.assign(containerElement.style, styles);

    // Add hover effect for subtle animation
    containerElement.addEventListener('mouseenter', () => {
      containerElement.style.transform = 'scale(1.05)';
      containerElement.style.boxShadow = '0 20px 60px rgba(0, 0, 0, 0.15)';
    });
    containerElement.addEventListener('mouseleave', () => {
      containerElement.style.transform = 'scale(1)';
      containerElement.style.boxShadow = '0 12px 50px rgba(0, 0, 0, 0.1)';
    });

    // Title Section with Styled Text Component
    const nameText = new TextComponent('John Doe');
    const nameElement = nameText.create();
    nameElement.style.fontSize = '38px';
    nameElement.style.fontWeight = '700';
    nameElement.style.marginBottom = '15px';
    nameElement.style.color = '#333';
    containerElement.appendChild(nameElement);

    // Image Section with placeholder text and upload functionality
    const imageSection = new ImageComponent();
    const imageElement = imageSection.create();
    imageElement.style.borderRadius = '50%';
    imageElement.style.width = '140px';
    imageElement.style.height = '140px';
    imageElement.style.marginBottom = '30px';
    imageElement.style.backgroundColor = '#f0f0f0';
    imageElement.style.color = '#999';
    imageElement.style.display = 'flex';
    imageElement.style.alignItems = 'center';
    imageElement.style.justifyContent = 'center';
    imageElement.style.fontSize = '14px';
    imageElement.style.cursor = 'pointer';
    imageElement.textContent = 'Insert Your Image';

    // File input for uploading an image
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'none';

    // Handle image upload
    fileInput.addEventListener('change', event => {
      const target = event.target as HTMLInputElement;
      const file = target.files?.[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          if (reader.result) {
            imageElement.style.backgroundImage = `url(${reader.result})`;
            imageElement.style.backgroundSize = 'cover';
            imageElement.style.backgroundPosition = 'center';
            imageElement.textContent = ''; // Remove placeholder text
          }
        };
        reader.readAsDataURL(file);
      }
    });

    // Trigger file input on imageElement click
    imageElement.addEventListener('click', () => fileInput.click());

    containerElement.appendChild(imageElement);
    containerElement.appendChild(fileInput);

    // User Details Section using TwoColumnContainer for layout
    const userDetailsContainer = new TwoColumnContainer();
    const detailsElement = userDetailsContainer.create();
    detailsElement.style.display = 'flex';
    detailsElement.style.justifyContent = 'space-evenly';
    detailsElement.style.marginBottom = '30px';

    const roleText = new TextComponent('Web Developer');
    const professionText = new TextComponent('Full Stack Developer');
    roleText.create().style.fontSize = '18px';
    roleText.create().style.color = '#555';
    professionText.create().style.fontSize = '18px';
    professionText.create().style.fontStyle = 'italic';
    professionText.create().style.color = '#777';
    userDetailsContainer.create().appendChild(roleText.create());
    userDetailsContainer.create().appendChild(professionText.create());

    containerElement.appendChild(detailsElement);

    // User Description Section using TextComponent
    const descriptionText = new TextComponent(
      'Hello. I am John Doe, a passionate developer who loves creating innovative and user-friendly websites. I have experience in both front-end and back-end development.'
    );
    const descriptionElement = descriptionText.create();
    descriptionElement.style.fontSize = '16px';
    descriptionElement.style.lineHeight = '1.7';
    descriptionElement.style.marginBottom = '40px';
    descriptionElement.style.color = '#555';
    descriptionElement.style.textAlign = 'left';
    descriptionElement.style.padding = '0 10px';
    containerElement.appendChild(descriptionElement);

    return containerElement; // Return the final container element
  }
}



================================================
File: src/types/png.d.ts
================================================
declare module '*.png' {
  const content: string;
  export default content;
}



================================================
File: src/types/types.d.ts
================================================
declare global {
  // Define a type for component configuration options
  interface ComponentConfig {
    type: string;
    id: string;
    content?: string;
    styles?: ComponentStyles;
  }

  // Define a type for styles to apply on components
  interface ComponentStyles {
    color?: string;
    fontSize?: string;
    padding?: string;
    margin?: string;
    [key: string]: any;
  }

  // Define an interface for components stored on the canvas
  interface CanvasComponent {
    element: HTMLElement;
    config: ComponentConfig;
  }

  // Define types for drag and drop events
  interface DragEventHandlers {
    onDragStart: (event: DragEvent, componentId: string) => void;
    onDrop: (event: DragEvent) => void;
    onDragOver: (event: DragEvent) => void;
  }

  interface PageComponent {
    id: string;
    type: string;
    content: string;
    position: { x: number; y: number };
    dimensions: { width: number; height: number };
    style: { [key: string]: string };
    inlineStyle: string;
    classes: string[];
    dataAttributes: { [key: string]: string };
    imageSrc?: string | null;
    videoSrc?: string | null;
    props?: Record<string, any>;
  }

  // Define type for JSON data format for saving/loading
  interface LayoutData {
    components: ComponentConfig[];
  }

  // Assuming your PageBuilderDesign type looks something like this:
  interface PageBuilderDesign {
    pages?: Array<{
      id: string;
      components: Array<{
        type: string;
        id: string;
        props: Record<string, any>;
      }>;
    }>;
    [key: string]: any;
  }

  // Define interface for Dynamic components
  interface DynamicComponents {
    Basic: string[];
    Extra: string[];
    Custom: Record<string, CustomComponentConfig>;
  }

  // New interface for custom component settings
  interface CustomComponentSetting {
    name: string;
    functionName: string;
  }

  // Define interface for each custom component and its details
  interface CustomComponentConfig {
    component: string;
    svg?: string;
    title?: string;
    settings?: CustomComponentSetting[];
    props?: Record<string, any>;
  }

  // Define a union type for different device preview modes
  type DevicePreviewMode = 'desktop' | 'tablet' | 'mobile';
}

export {};



================================================
File: src/utils/eventHelpers.ts
================================================
//event helper
export function addEvent(
  el: HTMLElement,
  event: string,
  handler: EventListener
) {
  el.addEventListener(event, handler);
}



================================================
File: src/utils/utilityFunctions.ts
================================================
//Function for toggling notification
export function showNotification(message: string) {
  const notification = document.getElementById('notification');
  if (notification) {
    notification.innerHTML = message;
    notification.classList.add('visible');
    notification.classList.remove('hidden');

    // Hide the notification after 2 seconds
    setTimeout(() => {
      notification.classList.remove('visible');
      notification.classList.add('hidden');
    }, 2000);
  }
}

//Function for handling dialog box, where confirmation and cancellation functions are passed as parameters
export function showDialogBox(
  message: string,
  onConfirm: () => void,
  onCancel: () => void
) {
  // Get the dialog and buttons from the DOM
  const dialog = document.getElementById('dialog');
  const yesButton = document.getElementById('dialog-yes');
  const noButton = document.getElementById('dialog-no');

  // Set the dialog message
  const messageElement = document.getElementById('dialog-message');
  if (messageElement) {
    messageElement.innerHTML = message;
  }

  // Show the dialog by removing the 'hidden' class
  dialog?.classList.remove('hidden');

  // Handle the 'Yes' button click
  yesButton?.addEventListener('click', () => {
    onConfirm(); // Execute the onConfirm function
    dialog?.classList.add('hidden'); // Hide the dialog after action
  });

  // Handle the 'No' button click
  noButton?.addEventListener('click', () => {
    onCancel(); // Execute the onCancel function
    dialog?.classList.add('hidden'); // Hide the dialog after action
  });
}
export function syntaxHighlightHTML(html: string): string {
  return html
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(
      /\s([a-zA-Z-]+)="(.*?)"/g,
      (match, attr, value) =>
        ` ${attr}=<span class="attribute">"</span><span class="string">${value}</span><span class="attribute">"</span>`
    )
    .replace(/(&lt;\/?[a-zA-Z-]+&gt;)/g, `<span class="tag">$1</span>`);
}

export function syntaxHighlightCSS(css: string): string {
  return css
    .replace(/([a-zA-Z-]+)(?=:)/g, `<span class="property">$1</span>`) // CSS properties
    .replace(/(:\s*[^;]+;)/g, `<span class="value">$1</span>`) // CSS values
    .replace(/({|})/g, `<span class="bracket">$1</span>`); // Braces
}

export function debounce(func: Function, delay: number) {
  let timeoutId: NodeJS.Timeout | null = null;
  return (...args: any[]) => {
    if (timeoutId) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func(...args), delay);
  };
}



================================================
File: src/utils/zipGenerator.ts
================================================
export function createZipFile(
  files: { name: string; content: string }[]
): Blob {
  // Helper function to convert string to Uint8Array
  const stringToUint8Array = (str: string): Uint8Array => {
    const encoder = new TextEncoder();
    return encoder.encode(str);
  };

  // Generate local file header
  const createLocalFileHeader = (
    fileName: Uint8Array,
    fileContent: Uint8Array,
    crc: number
  ): Uint8Array => {
    const header = new Uint8Array(30 + fileName.length);

    // Local file header signature
    header.set([0x50, 0x4b, 0x03, 0x04]);

    // Version needed to extract (2.0)
    header.set([0x14, 0x00], 4);

    // General purpose bit flag (no compression)
    header.set([0x00, 0x00], 6);

    // Compression method (0 = stored)
    header.set([0x00, 0x00], 8);

    // Last mod file time (current time)
    header.set([0x00, 0x00], 10);

    // Last mod file date (current date)
    header.set([0x00, 0x00], 12);

    // CRC-32
    header.set(
      [crc & 0xff, (crc >> 8) & 0xff, (crc >> 16) & 0xff, (crc >> 24) & 0xff],
      14
    );

    // Compressed size
    header.set(
      [
        fileContent.length & 0xff,
        (fileContent.length >> 8) & 0xff,
        (fileContent.length >> 16) & 0xff,
        (fileContent.length >> 24) & 0xff,
      ],
      18
    );

    // Uncompressed size
    header.set(
      [
        fileContent.length & 0xff,
        (fileContent.length >> 8) & 0xff,
        (fileContent.length >> 16) & 0xff,
        (fileContent.length >> 24) & 0xff,
      ],
      22
    );

    // Filename length
    header.set([fileName.length & 0xff, (fileName.length >> 8) & 0xff], 26);

    // Extra field length
    header.set([0x00, 0x00], 28);

    // Filename
    header.set(fileName, 30);

    return header;
  };

  // Generate central directory header
  const createCentralDirectoryHeader = (
    fileName: Uint8Array,
    fileContent: Uint8Array,
    crc: number,
    localHeaderOffset: number
  ): Uint8Array => {
    const header = new Uint8Array(46 + fileName.length);

    // Central file header signature
    header.set([0x50, 0x4b, 0x01, 0x02]);

    // Version made by
    header.set([0x14, 0x00], 4);

    // Version needed to extract
    header.set([0x14, 0x00], 6);

    // General purpose bit flag
    header.set([0x00, 0x00], 8);

    // Compression method (0 = stored)
    header.set([0x00, 0x00], 10);

    // Last mod file time
    header.set([0x00, 0x00], 12);

    // Last mod file date
    header.set([0x00, 0x00], 14);

    // CRC-32
    header.set(
      [crc & 0xff, (crc >> 8) & 0xff, (crc >> 16) & 0xff, (crc >> 24) & 0xff],
      16
    );

    // Compressed size
    header.set(
      [
        fileContent.length & 0xff,
        (fileContent.length >> 8) & 0xff,
        (fileContent.length >> 16) & 0xff,
        (fileContent.length >> 24) & 0xff,
      ],
      20
    );

    // Uncompressed size
    header.set(
      [
        fileContent.length & 0xff,
        (fileContent.length >> 8) & 0xff,
        (fileContent.length >> 16) & 0xff,
        (fileContent.length >> 24) & 0xff,
      ],
      24
    );

    // Filename length
    header.set([fileName.length & 0xff, (fileName.length >> 8) & 0xff], 28);

    // Extra field length
    header.set([0x00, 0x00], 30);

    // File comment length
    header.set([0x00, 0x00], 32);

    // Disk number start
    header.set([0x00, 0x00], 34);

    // Internal file attributes
    header.set([0x00, 0x00], 36);

    // External file attributes
    header.set([0x00, 0x00, 0x00, 0x00], 38);

    // Relative offset of local header
    header.set(
      [
        localHeaderOffset & 0xff,
        (localHeaderOffset >> 8) & 0xff,
        (localHeaderOffset >> 16) & 0xff,
        (localHeaderOffset >> 24) & 0xff,
      ],
      42
    );

    // Filename
    header.set(fileName, 46);

    return header;
  };

  // Generate end of central directory record
  const createEndOfCentralDirectoryRecord = (
    fileCount: number,
    centralDirectorySize: number,
    centralDirectoryOffset: number
  ): Uint8Array => {
    const record = new Uint8Array(22);

    // End of central directory signature
    record.set([0x50, 0x4b, 0x05, 0x06]);

    // Number of this disk
    record.set([0x00, 0x00], 4);

    // Disk where central directory starts
    record.set([0x00, 0x00], 6);

    // Number of central directory records on this disk
    record.set([fileCount & 0xff, (fileCount >> 8) & 0xff], 8);

    // Total number of central directory records
    record.set([fileCount & 0xff, (fileCount >> 8) & 0xff], 10);

    // Size of central directory
    record.set(
      [
        centralDirectorySize & 0xff,
        (centralDirectorySize >> 8) & 0xff,
        (centralDirectorySize >> 16) & 0xff,
        (centralDirectorySize >> 24) & 0xff,
      ],
      12
    );

    // Offset of central directory
    record.set(
      [
        centralDirectoryOffset & 0xff,
        (centralDirectoryOffset >> 8) & 0xff,
        (centralDirectoryOffset >> 16) & 0xff,
        (centralDirectoryOffset >> 24) & 0xff,
      ],
      16
    );

    // Comment length
    record.set([0x00, 0x00], 20);

    return record;
  };

  // Combine all parts to create ZIP file
  const zipParts: Uint8Array[] = [];
  let currentOffset = 0;
  const centralDirectoryHeaders: Uint8Array[] = [];

  // Process each file
  files.forEach(file => {
    const fileName = stringToUint8Array(file.name);
    const fileContent = stringToUint8Array(file.content);

    // Calculate CRC-32
    const fileCrc = crc32(fileContent);

    // Create local file header
    const localHeader = createLocalFileHeader(fileName, fileContent, fileCrc);

    // Add local file header and content to zip parts
    zipParts.push(localHeader);
    zipParts.push(fileContent);

    // Create central directory header
    const centralHeader = createCentralDirectoryHeader(
      fileName,
      fileContent,
      fileCrc,
      currentOffset
    );
    centralDirectoryHeaders.push(centralHeader);

    // Update offset
    currentOffset += localHeader.length + fileContent.length;
  });

  // Add central directory headers
  zipParts.push(...centralDirectoryHeaders);

  // Calculate central directory size
  const centralDirectorySize = centralDirectoryHeaders.reduce(
    (sum, header) => sum + header.length,
    0
  );

  // Create and add end of central directory record
  const endOfCentralDirectory = createEndOfCentralDirectoryRecord(
    files.length,
    centralDirectorySize,
    currentOffset
  );
  zipParts.push(endOfCentralDirectory);

  // Combine all parts into a single Uint8Array
  const zipArray = new Uint8Array(
    zipParts.reduce(
      (acc: number[], part: Uint8Array) => acc.concat(Array.from(part)),
      []
    )
  );

  // Create and return Blob
  return new Blob([zipArray], { type: 'application/zip' });
}

// CRC-32 implementation
function crc32(data: Uint8Array): number {
  // Simple CRC-32 implementation
  let crc = 0xffffffff;
  for (let i = 0; i < data.length; i++) {
    crc ^= data[i];
    for (let j = 0; j < 8; j++) {
      crc = (crc >>> 1) ^ (crc & 1 ? 0xedb88320 : 0);
    }
  }
  return crc ^ 0xffffffff;
}


